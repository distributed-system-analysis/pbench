#! /bin/bash
# set -x

# This shim is used to prepare the tarballs that a version 002 client
# submits for further processing. It copies the tarballs and their MD5
# sums to the archive (after checking) and sets the state links, so
# that the associates scripts will pick them up and get the ball
# rolling. IOW, it does impedance matching between version 002 clients
# and the server scripts.

###########################################################################
# load common things
opts=$SHELLOPTS
case $opts in
    *xtrace*)
        dir=$(dirname $(which $0))
        PROG=$(basename $(which $0))
        ;;
    *)
        dir=$(dirname $0)
        PROG=$(basename $0)
        ;;
esac

. $dir/pbench-base.sh
###########################################################################

errlog=$LOGSDIR/$PROG/$PROG.error
mkdir -p $LOGSDIR/$PROG
sts=$?
if [ $sts != 0 ]; then
    echo "Failed: \"mkdir -p $LOGSDIR/$PROG\", status $sts" >> $errlog
    exit 1
fi

archive=$(getconf.py archive-dir pbench-server)
if [[ "${archive}" == "" ]] ;then
    echo "Failed: \"getconf.py archive-dir pbench-server\", status $sts" >> $errlog
    exit 2
fi

qdir=$(getconf.py quarantine-dir pbench-server)
if [[ "$qdir" == "" ]] ;then
    echo "Failed: \"getconf.py quarantine-dir pbench-server\", status $sts" $errlog
    exit 2
fi

# we are explicitly handling version-002 data in this shim
results_dir=$(getconf.py receive-dir-002 pbench-server)
if [[ "$results_dir" == "" ]] ;then
    echo "Failed: \"getconf.py receive-dir-001 pbench-server\", status $sts" >> $errlog
    exit 2
fi

quarantine=${qdir}/md5-002
mkdir -p ${quarantine}
sts=$?
if [ $sts != 0 ]; then
    echo "Failed: \"mkdir -p ${quarantine}\", status $sts" >> $errlog
    exit 3
fi

duplicates=${qdir}/duplicates-002
mkdir -p ${duplicates}
sts=$?
if [ $sts != 0 ]; then
    echo "Failed: \"mkdir -p ${duplicates}\", status $sts" >> $errlog
    exit 3
fi

# The following directory holds tarballs that are quarantined because
# of operational errors on the server. They should be retried after
# the problem is fixed: basically, move them back into the reception
# area for 002 agents and wait.
errors=${qdir}/errors-002
mkdir -p ${errors}
sts=$?
if [ $sts != 0 ]; then
    echo "Failed: \"mkdir -p ${errors}\", status $sts" >> $errlog
    exit 3
fi

log_init $(basename $0) $LOGSDIR/$(basename $0)

tmp=$TMP/$PROG.$$

trap 'rm -rf $tmp' EXIT INT QUIT

mkdir -p $tmp
sts=$?
if [ $sts != 0 ]; then
    echo "Failed: \"mkdir -p $tmp\", status $sts" >> $errlog
    log_finish
    exit 4
fi

linkdestlist=$(getconf.py -l dispatch-states pbench-server)
list=$tmp/list.check
index_content=$tmp/index_mail_contents

# Initialize index mail content
> $index_content

echo $TS
# Check for results that are ready for processing: version 002 agents
# upload the MD5 file as xxx.md5.check and they rename it to xxx.md5
# after they are done with MD5 checking so that's what we look for.
find ${results_dir} -maxdepth 2 -name *.tar.xz.md5 > $list
sts=$?
if [ $sts != 0 ] ;then
    echo "Failed: \"find ${results_dir} -maxdepth 2 -name *.tar.xz.md5'\", status $sts" >&4
    log_finish
    exit 5
fi

typeset -i ntotal=0
typeset -i ntbs=0
typeset -i nerrs=0
typeset -i nquarantined=0
typeset -i ndups=0

while read result ;do
    ntotal=$ntotal+1
    # full pathname of tarball
    tb=${result%.md5}

    # directory
    tbdir=$(dirname ${tb})

    # resultname: get the basename foo.tar.xz and then strip the .tar.xz
    resultname=$(basename ${tb})
    resultname=${resultname%.tar.xz}

    # the controller hostname is the last component of the directory part
    # of the full path
    controller=$(basename ${tbdir})

    dest=${archive}

#    # Make sure the inotify state directories are present
#    for state in $linkdestlist ;do
#        if [ ! -d "${INOTIFY_STATE_DIR}/$state" ]; then
#            mkdir -p ${INOTIFY_STATE_DIR}/$state
#            sts=$?
#            if [ $sts -ne 0 ] ;then
#                echo "$TS: Failed: \"mkdir -p ${INOTIFY_STATE_DIR}/$state\", status $sts" | tee -a $index_content >&4
#            fi
#        fi
#    done

    # sanity checks
    if [ ! -f ${tb} ] ;then
        echo "$TS: Quarantined MD5: ${tb} file does not exist" >&4
        if [ -f ${tb}.md5 ] ;then
            quarantine ${quarantine}/${controller} ${tb}.md5
            nquarantined=${nquarantined}+1
        fi
        continue
    fi
    
    # Impossible: the md5 file disappeared between the find and this check!
    if [ ! -f ${tb}.md5 ] ;then
        echo "$TS: Quarantined: ${tb}.md5 file does not exist" >&4
        quarantine ${quarantine}/${controller} ${tb}
        nquarantined=${nquarantined}+1
        continue
    fi

    # check the md5sum
    pushd ${tbdir} >/dev/null 2>&4
    md5sum --check ${resultname}.tar.xz.md5
    sts=$?
    if [ $sts -ne 0 ] ;then
        echo "$TS: Quarantined: ${tb} failed MD5 check" >&4
        quarantine ${quarantine}/${controller} ${tb} ${tb}.md5
        nquarantined=$nquarantined+1
        popd >/dev/null 2>&4
        continue
    fi
    popd > /dev/null 2>&4

    if [ -f ${dest}/${resultname}.tar.xz -o -f ${dest}/${resultname}.tar.xz.md5 ] ;then
        echo "$TS: Duplicate: ${tb} duplicate name" >&4
        quarantine ${duplicates}/${controller} ${tb} ${tb}.md5
        ndups=$ndups+1
    fi

    # Create the trie structure using md5sum
    hash=$(md5sum "${tb}" | awk '{ print $1 }')
    if [ -z $hash ]; then
        quarantine ${errors}/${controller} ${tb} ${tb}.md5
        echo "$TS: Failed: md5sum ${tb}" | tee -a $index_content >&4
        nerrs=$nerrs+1
        continue
    fi

    hash_path=$(echo $hash | cut -b 1-2)/$(echo $hash | cut -b 3-4)/$(echo $hash | cut -b 5-)
    if [ -z $hash_path ]; then
        quarantine ${errors}/${controller} ${tb} ${tb}.md5
        echo "$TS: Failed to evaluate the trie structure path" | tee -a $index_content >&4
        nerrs=$nerrs+1
        continue
    fi

    # Create the trie structure path if not present
    result_full_path="${dest}/$hash_path"
    if [ ! -d "$result_full_path" ]; then
        mkdir -p $result_full_path
        sts=$?
        if [ $sts -ne 0 ] ;then
            quarantine ${errors}/${controller} ${tb} ${tb}.md5
            echo "$TS: Failed: \"mkdir -p $result_full_path\", status $sts" | tee -a $index_content >&4
            nerrs=$nerrs+1
            continue
        fi
    fi

#    # Make an entry in the hostnames directory if not present
#    hostnames_full_path="${dest}/hostnames/${controller}"
#    if [ ! -d "${hostnames_full_path}" ]; then
#        mkdir -p ${hostnames_full_path}
#        sts=$?
#        if [ $sts -ne 0 ] ;then
#            quarantine ${errors}/${controller} ${tb} ${tb}.md5
#            echo "$TS: Failed: \"mkdir -p ${hostnames_full_path}\", status $sts" | tee -a $index_content >&4
#            nerrs=$nerrs+1
#            continue
#        fi
#    fi

    # make sure that all the relevant state directories exist
    mk_dirs inotify_state
    status=$?
    if [[ $status -ne 0 ]] ;then
        quarantine ${errors}/${controller} ${tb} ${tb}.md5
        echo "$TS: Creation of $controller processing directories failed: code $status" | tee -a $index_content >&4
        nerrs=$nerrs+1
        continue
    fi

    # move the tarball and its md5
    mv ${tb} ${tb}.md5 ${result_full_path}
    sts=$?
    if [ $sts -ne 0 ] ;then
        quarantine ${errors}/${controller} ${tb} ${tb}.md5
        echo "$TS: Failed: \"mv ${tb} ${tb}.md5 $result_full_path\", status $sts" | tee -a $index_content >&4
        nerrs=$nerrs+1
        continue
    fi

    # generate the hostname file
    tb_name=${tb##*/}
    echo ${controller} > ${result_full_path}/${tb_name}.hostname
    sts=$?
    if [ $sts -ne 0 ] ;then
        quarantine ${errors}/${controller} ${result_full_path}/${tb_name} \
        ${result_full_path}/${tb_name}.md5 \
        ${result_full_path}/${tb_name}.hostname
        echo "$TS: Failed: \"echo ${controller} > ${result_full_path}/${tb_name}.hostname\", status $sts" | tee -a $index_content >&4
        nerrs=$nerrs+1
        continue
    fi

    # create a link in each state dir - if any fail, we should delete them all?# No, that would be racy.
    for state in $linkdestlist ;do
#        ln -s $result_full_path/${tb_name} $hostnames_full_path/$state
#        status=$?
#        if [[ $status -ne 0 ]] ;then
#            quarantine ${errors}/${controller} ${result_full_path}/${tb_name} \
#            ${result_full_path}/${tb_name}.md5 \
#            ${result_full_path}/${tb_name}.hostname
#            echo "$TS: Cannot create $result_full_path/${tb_name} link from $linksrc to $state: code $status" | tee -a $index_content >&4
#            nerrs=$nerrs+1
#            continue
#	fi
        watched_dir=${INOTIFY_STATE_DIR}/$state
        ln -s $result_full_path/${tb_name} ${watched_dir}/$hash
        sts=$?
        if [ $sts -ne 0 ] ;then
            quarantine ${errors}/${controller} ${result_full_path}/${tb_name} \
            ${result_full_path}/${tb_name}.md5 \
            ${result_full_path}/${tb_name}.hostname
            rm $hostnames_full_path/$state/${tb_name}
            echo "$TS: Failed: \"ln -s $result_full_path/${tb_name} ${watched_dir}/$md5\", status $sts" | tee -a $index_content >&4
            nerrs=$nerrs+1
            continue
        fi
    done

    # log the success
    echo "$TS: processed ${tb}" >> $index_content
    ntbs=$ntbs+1
done < $list

echo "$TS: Processed $ntotal entries, $ntbs tarballs successful,\
   # $nquarantined quarantined tarballs, $ndups duplicately-named tarballs,\
    $nerrs errors." | tee -a $index_content

log_finish

pbench-report-status --name $PROG --timestamp $TS --type status $index_content

exit $nerrs
