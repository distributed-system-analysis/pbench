#!/bin/bash
# -*- mode: shell-script; indent-tabs-mode: t; sh-basic-offset: 8; sh-indentation: 8; tab-width: 8 -*-

# NOTE: this script is used for many different tool names.  All are links to
# the same file.

tool="$(basename ${0})"
script_path="$(dirname ${0})"
script_path="$(realpath -e ${script_path})"
pbench_bin="$(dirname ${script_path})"

if [[ -z "${pbench_bin}" || "${pbench_bin}" == "/" ]]; then
	printf -- "INTERNAL ERROR - seems like tools incorrectly installed!" >&2
	exit 1
fi

# source the base script
. "${pbench_bin}"/base

datalog_path=${pbench_bin}/tool-scripts/datalog
postprocess_path=${pbench_bin}/tool-scripts/postprocess

# Pbench tool scripts must provide the following functions
# 1) Install the tool
# 2) Start data collection
# 3) Stop data collection
# 4) Post-process the data

shortoptions="hd"
longoptions="help,dir:,install,start,stop,postprocess"

# Defaults for all tools
tool_dir=""
mode=""

# Defaults for all tools except a few
case "${tool}" in
blktrace|bpftrace|kvmtrace|lockstat|perf|strace|systemtap|tcpdump)
	:  # These tools don't use interval
	;;
*)
	def_interval=10
	interval=${def_interval}
	longoptions="${longoptions},interval:"
	;;
esac

# Defaults specific to certain tools
case "${tool}" in
blktrace)
	devices=""
	longoptions="${longoptions},devices:"
	;;
bpftrace)
	script=""
	longoptions="${longoptions},script:"
	tool_package_name="bpftrace"
	;;
iostat|mpstat|sar)
	options=""
	longoptions="${longoptions},options:"
	tool_package_name="pbench-sysstat"
	tool_package_ver="12.0.3"
	;;
kvmtrace)
	def_start_delay=0
	start_delay=${def_start_delay}
	def_timeout=1
	timeout=${def_timeout}
	vm=""
	longoptions="${longoptions},start-delay:,timeout:,vm:"
	tool_package_name="trace-cmd"
	;;
numastat)
	pattern=""
	longoptions="${longoptions},pattern:"
	;;
perf)
	def_record_opts="-a --freq=100"
	record_opts="${def_record_opts}"
	def_report_opts="--show-nr-samples -I"
	report_opts="${def_report_opts}"
	callgraph_requested=""
	shortoptions="${shortoptions}r:p:"
	longoptions="${longoptions},callgraph,record-opts:,report-opts:"
	tool_package_name="perf"
	;;
pidstat)
	options=""
	patterns=""
	threads="false"
	longoptions="${longoptions},options:,patterns:,threads"
	tool_package_name="pbench-sysstat"
	tool_package_ver="12.0.3"
	;;
rabbit)
	def_username="guest"
	username="${def_username}"
	def_password="guest"
	password="${def_password}"
	longoptions="${longoptions},username:,password:"
	;;
strace|jmap|jstack)
	pid="0"
	pattern=""
	longoptions="${longoptions},pid:,pattern:"
	;;
sysfs)
	maxdepth=4
	path=""
	pattern='*'
	longoptions="${longoptions},maxdepth:,path:,pattern:"
	;;
systemtap)
	script=""
	longoptions="${longoptions},script:"
	;;
tcpdump)
	interface=""
	packets=500
	longoptions="${longoptions},interface:,packets:"
	;;
turbostat)
	release="$(awk '{x=$7; split(x, a, "."); print a[1];}' /etc/redhat-release 2> /dev/null)"
	case "${release}" in
	6)
		tool_package_name="cpupowerutils"
		;;
	*)
		tool_package_name="kernel-tools"
		;;
	esac
	;;
virsh-migrate|qemu-migrate)
	vm=""
	longoptions="${longoptions},vm:"
	;;
esac

function usage {
	printf -- "The following options are available:\n\n"
	printf -- "\t--install                 verify this perf tool will work\n\n"
	printf -- "\t--start|stop|postprocess  start/stop/postprocess the data collection\n"
	printf -- "\t-d str|--dir=str          directory to store data collection (required)\n"
	case "${tool}" in
	blktrace|bpftrace|kvmtrace|lockstat|perf|strace|systemtap|tcpdump)
		:  # These tools don't use interval
		;;
	*)
		printf -- "\t--interval=int            number of seconds between each data collection (optional, default is %s seconds)\n" "${def_interval}"
		;;
	esac
	case "${tool}" in
	blktrace)
		printf -- "\t--devices=str,[str]       the list of block devices to trace (required w/ --start)\n"
		;;
	bpftrace)
		printf -- "\t--script=str              path to the bpftrace script (required w/ --start)\n"
		;;
	iostat|mpstat|sar)
		printf -- "\t--options=str             options passed directly to the tool (optional)\n"
		;;
	kvmtrace)
		printf -- "\t--vm=str                  the hostname of the vm running (to get kallsyms)\n"
		printf -- "\t--timeout=int             how long the trace will run (default is %s second)\n" "${def_timeout}"
		printf -- "\t                          If 0 is used, the trace will not stop until stop-tools is called\n"
		printf -- "\t--start-delay=int         sleep this many seconds before starting the trace (default is %s seconds)\n" "${def_start_delay}"
		;;
	numastat)
		printf -- "\t--pattern=str             a pattern for matching which processes for reporting per-node memory allocation\n"
		;;
	perf)
		printf -- "\t-r str|--record-opts=str  options one would use to record perf data (optional, default: '%s'\n" "${def_record_opts})"
		printf -- "\t-p str|--report-opts=str  options one would use to report perf data (optional, default: '%s'\n" "${def_report_opts})"
		printf -- "\t--callgraph               generate a call graph by adding '-g' to the record and report options\n"
		;;
	pidstat)
		printf -- "\t--options=str             options passed directly to the tool\n"
		printf -- "\t--patterns=str[,str]      only collect information on process names\n"
		printf -- "\t                          which match this pattern (complicated\n"
		printf -- "\t                          patterns with special charaters may not\n"
		printf -- "\t                          work) for kvm, use --patterns=qemu,vhost\n"
		printf -- "\t--threads                 collect per-thread statistics\n"
		;;
	rabbit)
		printf -- "\t--username=str            rabbit user name (default is \"%s\")\n" "${def_username}"
		printf -- "\t--password=str            rabbit password (default is \"%s\")\n" "${def_password}"
		;;
	strace|jmap|jstack)
		printf -- "\t--pid=int                 a process ID to %s\n" "${tool}"
		printf -- "\t--pattern=str             %s any PID which name matches this string (via pgrep)\n" "${tool}"
		;;
	sysfs)
		printf -- "\t--path=str                a path (beyond the /sysfs prefix)\n"
		printf -- "\t--pattern=str             a pattern passed to -name option of find command to filter files\n"
		printf -- "\t--maxdepth=int            a maxdepth passed to the find command to limit recursion depth\n"
		;;
	systemtap)
		printf -- "\t--script=str              path to the systemtap script (required w/ --install)\n"
		;;
	tcpdump)
		printf -- "\t--interface=str           the network interface to monitor\n"
		printf -- "\t--packets=int             the number of packets to monitor before exiting\n"
		;;
	virsh-migrate|qemu-migrate)
		printf -- "\t--vm=str                  the name of the VM being migrated\n"
		;;
	esac
	printf -- "\n\t-h|--help                 display this help message\n"
}

# Process options and arguments
opts="$(getopt -q -o ${shortoptions} --longoptions "${longoptions}" -n "${tool}" -- "${@}")"
if [[ ${?} -ne 0 ]]; then
	printf -- "\n%s: encountered an invalid option, ${@}\n\n" "${tool}" >&2
	usage >&2
	exit 1
fi
eval set -- "${opts}"
while true; do
	opt="${1}"
	shift
	case "${opt}" in
	-h|--help)
		usage
		exit 0
		;;
	--install)
		mode="install"
		;;
	--start)
		mode="start"
		;;
	--stop)
		mode="stop"
		;;
	--postprocess)
		mode="postprocess"
		;;
	-d|--dir)
		if [[ -n "${1}" ]]; then
			tool_dir="${1}"
			shift
		fi
		;;
	--interval)
		if [[ -n "${1}" ]]; then
			interval="${1}"
			shift
		fi
		;;
	--callgraph)
		callgraph_requested="true"
		;;
	--devices)
		if [[ -n "${1}" ]]; then
			devices="${1//,/ }"
			shift
		fi
		;;
	--maxdepth)
		if [[ -n "${1}" ]]; then
			maxdepth="${1}"
			shift
		fi
		;;
	--interface)
		if [[ -n "${1}" ]]; then
			interface="${1}"
			shift
		fi
		;;
	--options)
		if [[ -n "${1}" ]]; then
			options="${1}"
			shift
		fi
		;;
	--packets)
		if [[ -n "${1}" ]]; then
			packets="${1}"
			shift
		fi
		;;
	--path)
		if [[ -n "${1}" ]]; then
			path="${1}"
			shift
		fi
		;;
	--patterns)
		if [[ -n "${1}" ]]; then
			patterns="${1}"
			shift
		fi
		;;
	--pattern)
		if [[ -n "${1}" ]]; then
			pattern="${1}"
			shift
		fi
		;;
	--pid)
		if [[ -n "${1}" ]]; then
			pid="${1}"
			shift
		fi
		;;
	-r|--record-opts)
		if [[ -n "${1}" ]]; then
			record_opts="${1}"
			shift
		fi
		;;
	-p|--report-opts)
		if [[ -n "${1}" ]]; then
			report_opts="${1}"
			shift
		fi
		;;
	--script)
		if [[ -n "${1}" ]]; then
			script="$(echo "${1}" | sed 's/^"\(.*\)"$/\1/')"
			shift
		fi
		;;
	--start-delay)
		if [[ -n "${1}" ]]; then
			start_delay="${1}"
			shift
		fi
		;;
	--threads)
		threads="true"
		;;
	--timeout)
		if [[ -n "${1}" ]]; then
			timeout="${1}"
			shift
		fi
		;;
	--vm)
		if [[ -n "${1}" ]]; then
			vm="${1}"
			shift
		fi
		;;
	--)
		break
		;;
	*)
		printf -- "${tool}: Error, invalid command line option, '${opt}'\n\n" >&2
		usage >&2
		exit 1
	esac
done

if [[ -z "${mode}" ]]; then
	printf -- "%s: Error, one of the following options is required, --install|--start|--stop|--postprocess\n\n" "${tool}" >&2
	usage >&2
	exit 1
fi

if [[ "${mode}" != "install" && ( -z "${tool_dir}" || ! -d "${tool_dir}" ) ]]; then
	printf -- "%s: Error, --dir argument is required with a valid directory\n\n" "${tool}" >&2
	usage >&2
	exit 1
fi

tool_output_dir="${tool_dir}/${tool}" # all tools keep data in their tool specific dir
tool_pid_file="${tool_output_dir}/${tool}.pid"

function safe_kill() {
	# safe kill: check for strange situations and deal with them.  If
	# there is a pid, try to kill it.  If the kill succeeds, return
	# success, but if it fails, try to see if the pid is still running: if
	# so, try to kill it with a KILL and return failure.  Eat any error
	# message.
	local tool="${1}"
	local pid="${2}"
	local signal="${3:-TERM}"
	local pidlist p pid_to_kill len rc

	if [[ -z "${pid}" ]]; then
		# Should not happen
		return 1
	fi

	# Check that the pid corresponds to the tool.
	pidlist="$(pidof -x ${tool})"
	for p in ${pidlist}; do
		if [[ ${p} == ${pid} ]]; then
			pid_to_kill="${pid}"
			break
		fi
	done

	rc=0
	if [[ ! -z "$pid_to_kill" ]]; then
		kill -s ${signal} ${pid_to_kill} 2>/dev/null
		rc=${?}
	fi
	[[ $rc == 0 ]] && return 0

	# Check if the process is still running.
	pid_to_kill=""
	typeset -i len=0
	pidlist="$(pidof -x ${tool})"
	for p in ${pidlist}; do
		len=${len}+1
		if [[ ${p} == ${pid} ]]; then
			# Why is the pid still there?
			pid_to_kill="${pid}"
		# else
			# Why are there other tool processes running?
			# Should we kill them?
		fi
	done

	if [[ ! -z "${pid_to_kill}" ]]; then
		kill -s KILL ${pid_to_kill} 2>/dev/null
		return 2
	fi

	if [[ ${len} > 4 || (${len} > 3 && ${tool} != "turbostat") ]]; then
		warn_log "Too many pids for ${tool}: ${pidlist} -- maybe old tools running? Use pbench-kill-tools."
	fi
	return 0
}

# return code
rc=0
case "${mode}" in
install)
	case "${tool}" in
	bpftrace|kvmtrace|mpstat|iostat|sar|perf|pidstat|turbostat)
		check_install_rpm ${tool_package_name} ${tool_package_ver}
		rc=${?}
		;;
	systemtap)
		# The installation for systemtap includes compiling the kernel
		# module from the stap script; this is done to avoid extra
		# overhead when the workload is running.
		check_install_rpm systemtap-client
		rc=${?}
		if [[ ${rc} == 0 ]]; then
			check_install_rpm systemtap-devel
			rc=${?}
		fi
		if [[ ${rc} == 0 ]]; then
			check_install_rpm kernel-devel $(uname -r)
			rc=${?}
		fi
		if [[ ${rc} == 0 ]]; then
			check_install_rpm kernel-debuginfo $(uname -r)
			rc=${?}
		fi
		;;
	esac
	;;
start)
	case "${tool}" in
	blktrace)
		tool_cmd="${datalog_path}/${tool}-datalog ${devices}"
		;;
	bpftrace|systemtap)
		tool_cmd="${datalog_path}/${tool}-datalog ${script}"
		;;
	cpuacct|disk|dm-cache|docker|docker-info|kvm-spinlock|kvmstat|turbostat|vmstat)
		tool_cmd="${datalog_path}/${tool}-datalog ${interval}"
		;;
	iostat|mpstat)
		tool_cmd="${datalog_path}/${tool}-datalog ${interval} ${options}"
		;;
	jmap|jstack)
		tool_cmd="${datalog_path}/${tool}-datalog ${tool_output_dir} ${interval} ${pid} \"${pattern}\""
		;;
	kvmtrace)
		tool_cmd="${datalog_path}/${tool}-datalog ${timeout} ${start_delay}"
		;;
	lockstat)
		tool_cmd="${datalog_path}/${tool}-datalog ${tool_output_dir}"
		;;
	numastat)
		tool_cmd="${datalog_path}/${tool}-datalog ${interval} \"${pattern}\""
		;;
	openvswitch)
		tool_cmd="${datalog_path}/${tool}-datalog ${tool_output_dir} ${interval}"
		;;
	perf)
		if [[ ! -z "${callgraph_requested}" ]]; then
			record_opts="${record_opts} -g"
		fi
		tool_cmd="${datalog_path}/${tool}-datalog ${tool_output_dir} ${record_opts}"
		;;
	pidstat)
		tool_cmd="${datalog_path}/${tool}-datalog ${tool_output_dir} ${interval} ${threads} p='${patterns}' ${options}"
		;;
	proc-interrupts)
		tool_cmd="${datalog_path}/File-Capture-datalog ${interval} /proc/interrupts"
		;;
	proc-sched_debug)
		tool_cmd="${datalog_path}/File-Capture-datalog ${interval} /proc/sched_debug"
		;;
	proc-vmstat)
		tool_cmd="${datalog_path}/File-Capture-datalog ${interval} /proc/vmstat"
		;;
	qemu-migrate|virsh-migrate)
		tool_cmd="${datalog_path}/${tool}-datalog ${interval} ${vm}"
		;;
	rabbit)
		tool_cmd="${datalog_path}/${tool}-datalog ${interval} ${username} ${password}"
		;;
	sar)
		tool_cmd="${datalog_path}/${tool}-datalog ${tool_output_dir} ${interval} ${options}"
		;;
	strace)
		tool_cmd="${datalog_path}/${tool}-datalog ${tool_output_dir} ${pid} \"${pattern}\""
		;;
	sysfs)
		tool_cmd="${datalog_path}/${tool}-datalog ${interval} \"${path}\" \"${maxdepth}\" \"${pattern}\""
		;;
	tcpdump)
		tool_cmd="${datalog_path}/${tool}-datalog ${packets} ${interface}"
		;;
	psi)
		tool_cmd="${datalog_path}/${tool}-datalog ${interval} /proc/pressure"
		;;	
	*)
		error_log "INTERNAL ERROR: unsupported tool, ${tool}"
		exit 1
		;;
	esac
	mkdir -p "${tool_output_dir}"
	pushd "${tool_output_dir}" >/dev/null
	if [[ ${?} -ne 0 ]]; then
		error_log "${tool}: failed to create tool output directory, ${tool_output_dir}" >&2
		exit 1
	fi

	if [[ ! -z "${options}" ]]; then
		# Record any options for later post-processing use.
		echo "${options}" > ${tool_output_dir}/${tool}.options
	fi

	tool_cmd_file="${tool_output_dir}/${tool}.cmd"
	# Force LANG=C for all tools
	printf -- "#!/bin/bash\n# base-tool generated command file\n\nLANC=C %s\n" "${tool_cmd}" > "${tool_cmd_file}"
	chmod +x "${tool_cmd_file}"
	debug_log "${tool}: running \"${tool_cmd}\""
	tool_stdout_file="${tool_output_dir}/${tool}-stdout.txt"
	tool_stderr_file="${tool_output_dir}/${tool}-stderr.txt"
	${tool_cmd_file} > "${tool_stdout_file}" 2> "${tool_stderr_file}" & echo ${!} > "${tool_pid_file}"
	wait
	rc=0
	popd > /dev/null
	;;
stop)
	debug_log "stopping ${tool}"
	if [[ -s "${tool_pid_file}" ]]; then
		pid="$(cat ${tool_pid_file})"
		if [[ ! -z "${pid}" ]] ;then
			if [[ "${tool}" == "kvmtrace" ]]; then
				if [[ -z "${sleep_cmd}" ]]; then
					# kill the tool directly with an INT signal
					safe_kill ${tool} ${pid} INT
				else
					# kill the sleep process if it still exists
					sleep_pid="$(ps --ppid ${pid} | pgrep sleep)"
					if [[ ! -z "${sleep_pid}" ]]; then
						safe_kill ${tool} ${sleep_pid}
					fi
				fi
				# wait for the trace-cmd pid to complete
				while [[ -d /proc/${pid} ]]; do
					debug_log "waiting for PID ${pid} to die"
					sleep 0.5
				done
				rc=0
			elif [[ "${tool}" == "perf" ]]; then
				safe_kill "${tool}" ${pid} "INT"
				# Wait for perf to finish recording.  if you
				# do not wait, 'perf report' will not be
				# correct.  perf is not a child process, so we
				# cannot use "wait".
				pidcmd="$(ps -p ${pid} | tail -1 | awk '{print $4}')"
				while [[ -d /proc/${pid} ]]; do
					debug_log "Waiting for PID ${pid} (${pidcmd}) to finish"
					sleep 0.5
				done
			else
				safe_kill "${tool}" "${pid}"
				rc=${?}
			fi
			if [[ ${rc} -eq 0 ]]; then
				/bin/rm -f "${tool_pid_file}"
			fi
		else
			warn_log "[${tool}]: tool is not running, nothing to kill"
		fi
	else
		warn_log "[${tool}]: tool is not running, nothing to kill"
	fi
	if [[ ${rc} == 0 ]]; then
		# We only post-process if we were successfully able to stop the tool.
		if [[ -x ${postprocess_path}/${tool}-stop-postprocess ]]; then
			debug_log "post-processing ${tool} following stop"
			if [[ "${tool}" == "kvmtrace" ]]; then
				args="${vm}"
			elif [[ "${tool}" == "perf" ]]; then
				if [[ ! -z "${callgraph_requested}" ]]; then
					report_opts="${report_opts} -g"
				fi
				args="${report_opts}"
			else
				args=""
			fi
			${postprocess_path}/${tool}-stop-postprocess "${tool_output_dir}" ${args} \
					>  ${tool_output_dir}/${tool}-stop-postprocess.out \
					2> ${tool_output_dir}/${tool}-stop-postprocess.err
			rc=${?}
		else
			debug_log "no post-processing available for ${tool} following stop"
			rc=0
		fi
	fi
	;;
postprocess)
	if [[ -x ${postprocess_path}/${tool}-postprocess ]]; then
		debug_log "post-processing ${tool} data"
		${postprocess_path}/${tool}-postprocess "${tool_output_dir}" \
				>  ${tool_output_dir}/${tool}-postprocess.out \
				2> ${tool_output_dir}/${tool}-postprocess.err
		rc=${?}
	else
		debug_log "no data post-processing available for ${tool}"
		rc=0
	fi
	;;
*)
	error_log "${tool}: unexpected mode: ${mode}, no action taken"
	rc=1
	;;
esac

exit ${rc}
