#!/bin/bash
# -*- mode: shell-script; indent-tabs-mode: t; sh-basic-offset: 8; sh-indentation: 8; sh-indent-for-case-alt: + -*-

script_path="$(dirname ${0})"
script_name="$(basename ${0})"
pbench_bin="$(realpath -e ${script_path}/..)"

# source the base script
. "${pbench_bin}"/base

# The sole purpose of this script is to ensure a set of pre-defined tools of
# your choosing are used during the execution of a benchmark.  For a list of
# performance tools, look at the ${pbench_bin}/tool-scripts directory.

# Defaults
toolset="default"
remote=""
label=""
group=""
default_interval=$(getconf.py interval pbench/tools)
if [[ -z "${default_interval}" ]] ;then
    default_interval=3
fi

function usage() {
    printf "usage:\n"
    printf "$script_name --toolset=<tool-set> [--group=<group-name>] [--remote=<remote-host>] [--label=<label>] [--interval=<interval] -- [all tool specific options here]\n"
}

# Process options and arguments
opts=$(pbench-argparse -q -o hr:l:g:i: --longoptions "help,toolset:,remote:,label:,group:,interval:" -n "${script_name}" -- "${@}")
sts=${?}
if [[ ${sts} -ne 0 ]]; then
    printf -- "\n" >&2
    usage >&2
    exit ${sts}
fi

eval set -- "${opts}"
while true; do
    opt="${1}"
    shift
    case "${opt}" in
	--toolset)
	    if [[ -z "${1}" ]]; then printf -- "Logic bomb! empty argument for ${opt}\n" >&2; exit 100; fi
	    toolset="${1}"
	    shift
	    ;;
	-r|--remote)
	    if [[ -z "${1}" ]]; then printf -- "Logic bomb! empty argument for ${opt}\n" >&2; exit 100; fi
	    remote="--remote=${1}"
	    shift
	    ;;
	-l|--label)
	    if [[ -z "${1}" ]]; then printf -- "Logic bomb! empty argument for ${opt}\n" >&2; exit 100; fi
	    label="--label=${1}"
	    shift
	    ;;
	-g|--group)
	    if [[ -z "${1}" ]]; then printf -- "Logic bomb! empty argument for ${opt}\n" >&2; exit 100; fi
	    group="--group=${1}"
	    shift
	    ;;
	-i|--interval)
	    if [[ -z "${1}" ]]; then printf -- "Logic bomb! empty argument for ${opt}\n" >&2; exit 100; fi
	    default_interval="${1}"
	    shift
	    ;;
	-h|--help)
	    usage
	    exit 0
	    ;;
	--)
	    break
	    ;;
	*)
	    printf "\n${script_name}: you specified an invalid option or provided an unexpected argument: \"${opt}\"\n\n" >&2
	    usage >&2
	    exit 1
	    ;;
    esac
done

typeset -i nerrs=0
case "$toolset" in
	default)
	default_tool_set=$(getconf.py -l default-tool-set pbench/tools)
	for tool_name in $default_tool_set; do
		if [[ ${tool_name} == "perf" ]]; then
			# Ignore, we'll register it after all the others
			# FIXME: Why is perf always registered?
			continue
		fi
		interval=$(getconf.py interval tools/${tool_name})
		if [ -z "${interval}" ] ;then
			interval=${default_interval}
		fi
		pbench-register-tool --name=${tool_name} $remote $label $group -- --interval="$interval"
		rc=$?
		if [ $rc != 0 ] ;then
			nerrs=$nerrs+1
		fi
	done
	# low overhead perf
	# FIXME: Why is perf always registered?
	pbench-register-tool --name=perf $remote $label $group -- --record-opts="record -a --freq=100"
	rc=$?
	if [ $rc != 0 ] ;then
		nerrs=$nerrs+1
	fi
	;;
esac

exit $nerrs
