#!/usr/bin/env python3
# -*- mode: python -*-

"""pbench-tool-meister-stop

Responsible for ending persistent tools, collecting any requested system
information, recording any necessary metadata about the Tool Meisters, and
stopping all local/remote tool meisters, closing down the local data sink, and
finally the local redis server.
"""

import errno
import logging
import os
import signal
import sys
import time

from argparse import ArgumentParser
from pathlib import Path

from pbench.agent.constants import redis_port, cli_tm_channel_prefix
from pbench.agent.tool_meister_client import Client
from pbench.agent.utils import (
    cli_verify_sysinfo,
    info_log,
    verify_tool_group,
    BadToolGroup,
)


def is_running(pid):
    """Is the given PID running?

    See https://stackoverflow.com/questions/7653178/wait-until-a-certain-process-knowing-the-pid-end
    """
    try:
        os.kill(pid, 0)
    except OSError as err:
        if err.errno == errno.ESRCH:
            return False
    return True


def main(_prog, cli_params):
    """Main program for the tool meister stop CLI interface.

    Stopping the Tool Meisters involves four steps:

    1. End ("end") the run of the persistent tools

    2. Collect any requested system configuration information ("sysinfo")

    3. Sends the "terminate" message to the redis server so that all connected
    services, tool-meisters, tool-data-sink, etc. will shutdown.  Once all
    services acknowledge the receipt of the "terminate" message, we look to
    ensure that the local Tool Data Sink and optional Tool Meister instance
    have shutdown by verifying their recorded pids are no longer seen on the
    local host.

    :cli_params: expects a CLI parameters object which has three attributes:

        * tool_group - The tool group from which to load the registered tools
        * interrupt  - True / False value indicating if the call to stop the
                       Tool Meisters is in response to an interrupt or not
        * sysinfo    - The system information set to be collected at the start

    Return 0 on success, 1 on failure.
    """
    PROG = Path(_prog)
    logger = logging.getLogger(PROG.name)
    if os.environ.get("_PBENCH_TOOL_MEISTER_STOP_LOG_LEVEL") == "debug":
        log_level = logging.DEBUG
    else:
        log_level = logging.INFO
    logger.setLevel(log_level)
    sh = logging.StreamHandler()
    sh.setLevel(log_level)
    shf = logging.Formatter("%(message)s")
    sh.setFormatter(shf)
    logger.addHandler(sh)

    try:
        verify_tool_group(cli_params.tool_group)
    except BadToolGroup as exc:
        logger.error(str(exc))
        return 1
    else:
        group = cli_params.tool_group

    sysinfo, bad_l = cli_verify_sysinfo(cli_params.sysinfo)
    if bad_l:
        logger.error('invalid sysinfo option(s), "{}"', ",".join(bad_l))

    interrupt = cli_params.interrupt
    if interrupt and sysinfo:
        # Don't collect system information if the CLI invocation specified an
        # interrupt occured.
        logger.warning("system information not collected when --interrupt specified")
        sysinfo = ""

    try:
        full_hostname = os.environ["_pbench_full_hostname"]
        benchmark_run_dir = Path(os.environ["benchmark_run_dir"]).resolve(strict=True)
    except Exception:
        logger.exception("failed to fetch parameters from the environment")
        return 1

    try:
        redis_server_pid_file = (
            benchmark_run_dir / "tm" / f"redis_{redis_port:d}.pid"
        ).resolve(strict=True)
    except FileNotFoundError:
        # No Redis server, nothing to do.
        return 0

    # The Redis server is always running on the local host with the CLI.
    with Client(
        redis_host="localhost",
        redis_port=redis_port,
        channel_prefix=cli_tm_channel_prefix,
        logger=logger,
    ) as client:
        # First we end the persistent tools
        tool_dir = benchmark_run_dir / f"tools-{group}"
        try:
            tool_dir.mkdir(exist_ok=True)
        except Exception as exc:
            logger.error(
                'failed to create tool output directory, "{}": {}', tool_dir, exc
            )
            end_ret_val = 1
        else:
            end_ret_val = client.publish(group, tool_dir, "end", None)

        # Next we collect the system configuration information, but only if the
        # "end" operation was successful, and if it was requested.
        if end_ret_val == 0 and sysinfo:
            sysinfo_path = benchmark_run_dir / "sysinfo" / "end"
            try:
                sysinfo_path.mkdir(parents=True)
            except Exception:
                logger.error(
                    "Unable to create sysinfo-dump directory base path: {}",
                    sysinfo_path,
                )
            else:
                logger.info("Collecting system information")
                info_log("Collecting system information")
                # We don't check the return status for the sysinfo operation
                # since the publish() method will log errors for us, and its
                # success or failure does not affect the return status of
                # stopping the Tool Meister sub-system.
                client.publish(group, sysinfo_path, "sysinfo", sysinfo)

        # Finally we terminate the running Tool Data Sinks and the Tool
        # Meisters, indicating if this termination is due to an interruption.
        # Note that we always issue the
        term_ret_val = client.terminate(group, interrupt)

    # If the "end" persistent tools operation failed, we want to be sure that
    # this command returns an error status.  If the "end" succeeded, then we
    # just return the success/failure of the terminate operation.
    ret_val = end_ret_val if end_ret_val != 0 else term_ret_val

    # The assumption/assertion here is that the tool meister "stop" command is
    # run on the same node as the tool meister "start" command ran, creating
    # the local Tool Data Sink and the optional local Tool Meister. We want to
    # make sure anything "local" to this stop command is shut down gracefully
    # before we report back to the user.  If Tool Meisters from remote nodes
    # have already reported that they have received the "terminate" message,
    # then we trust they will shutdown gracefully themselves.
    try:
        tds_pid_file = benchmark_run_dir / "tm" / "pbench-tool-data-sink.pid"
        try:
            pid_str = tds_pid_file.read_text()
        except OSError as exc:
            if exc.errno != errno.ENOENT:
                raise
        else:
            tds_pid = int(pid_str)
            logger.debug("waiting for tool-data-sink (%d) to exit", tds_pid)
            while is_running(tds_pid):
                time.sleep(0.1)
    except Exception:
        logger.exception("Exception encountered waiting for tool-data-sink")
        ret_val = 1

    try:
        ltm_pid_file = benchmark_run_dir / "tm" / f"tm-{group}-{full_hostname}.pid"
        try:
            pid_str = ltm_pid_file.read_text()
        except OSError as exc:
            if exc.errno != errno.ENOENT:
                raise
        else:
            ltm_pid = int(pid_str)
            logger.debug("waiting for local tool-meister (%d) to exit", ltm_pid)
            while is_running(ltm_pid):
                time.sleep(0.1)
    except Exception:
        logger.exception("Exception encountered waiting for local tool-meister")
        ret_val = 1

    # All was good so far, so we can terminate the Redis server.
    try:
        try:
            pid_str = redis_server_pid_file.read_text()
        except OSError as exc:
            if exc.errno != errno.ENOENT:
                raise
        else:
            redis_server_pid = int(pid_str)
            pid_exists = True
            while pid_exists:
                try:
                    os.kill(redis_server_pid, signal.SIGTERM)
                except ProcessLookupError:
                    pid_exists = False
                else:
                    time.sleep(0.1)
    except Exception:
        logger.exception("Exception encountered terminating Redis server")
        ret_val = 1

    return ret_val


_NAME_ = "pbench-tool-meister-stop"

if __name__ == "__main__":
    parser = ArgumentParser(
        f"Usage: {_NAME_} [--sysinfo <list of system information items>]"
    )
    parser.add_argument(
        "--sysinfo",
        default=None,
        help="The list of system information items to be collected.",
    )
    parser.add_argument(
        "--interrupt",
        action="store_true",
        help="Whether or not the stop operation is in response to an interrupt.",
    )
    parser.add_argument(
        "tool_group", help="The tool group of items being run in the Tool Meisters."
    )
    parsed = parser.parse_args()
    status = main(sys.argv[0], parsed)
    sys.exit(status)
