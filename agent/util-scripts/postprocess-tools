#!/bin/bash
# -*- mode: shell-script; indent-tabs-mode: t; sh-basic-offset: 8; sh-indentation: 8; sh-indent-for-case-alt: + -*-

script_path=`dirname $0`
script_name=`basename $0`
pbench_bin="`cd ${script_path}/..; /bin/pwd`"

# source the base script
. "$pbench_bin"/base

# This script will postprocess all tools that belong
# to a specific group.  This is typically called
# by a benchmark script when some activity needs to
# monitored.

# Defaults
group=default
dir="/tmp"
iteration=1

debug_log "[$script_name]started: $@"

# Process options and arguments

opts=$(getopt -q -o d:g: --longoptions "dir:,group:,iteration:" -n "getopt.sh" -- "$@");
if [ $? -ne 0 ]; then
	printf "\n"
	printf "$script_name: you specified an invalid option\n\n"
	printf "The following are required:\n\n"
	printf -- "\t-g str --group=str, str = a tool group used in a benchmark\n"
	printf -- "\t                          (the default group is 'default')\n"
	printf "\n"
	printf -- "\t-d str --dir=str, str = a directory where the $script_name\n"
	printf -- "\t                        will store and process data\n"
	printf "\n"
	printf -- "\t-i str --iteration=num, num = a number representing the\n"
	printf -- "\t                              iteration data was collected for"
	exit 1
fi
eval set -- "$opts";
while true; do
	case "$1" in
		-g|--group)
		shift;
		if [ -n "$1" ]; then
			group="$1"
			shift;
		fi
		;;
		-d|--dir)
		shift;
		if [ -n "$1" ]; then
			dir="$1"
			shift;
		fi
		;;
		-i|--iteration)
		shift;
		if [ -n "$1" ]; then
			iteration="$1"
			shift;
		fi
		;;
		--)
		shift;
		break;
		;;
	esac
done

if [ -f "$pbench_run/tools.$group" ]; then
	groupfile="$pbench_run/tools.$group"
else
	# if there were no tools registered for the group, use the
	# tools registered in the default group
	groupfile="$pbench_run/tools.default"
fi
if [ ! -f "$groupfile" ]; then
	error_log "[$script_name] failed to find tools group file, \"$groupfile\""
	exit 1
fi

tool_dir="$dir/tools-$group"
if [ ! -d $tool_dir ]; then
	error_log "[$script_name]missing tools group directory: $tool_dir"
	exit 1
fi

cmd_dir=$tool_dir/cmds
mkdir -p $cmd_dir
if [ ! -d $cmd_dir ]; then
	error_log "[$script_name]failed to create commands directory: $cmd_dir"
	exit 1
fi

function move_tool_data {
	local remote_host=$1
	local remote_label=$2
	local remote_shost=`echo $remote_host | awk -F. '{print $1}'`
	pushd $tool_dir >/dev/null
	tool_data_size=`ssh $ssh_opts -n $remote_host du -sm $tool_dir | awk '{print $1}'`
	debug_log "[$script_name]started: copying tool data ($tool_data_size MB) from $remote_host"
	ssh $ssh_opts -n $remote_host "cd $tool_dir && tar cf - *" | tar mxf -
	# if the full hostname was used in register-tool --remote, make sure that is preserved in the directory name
	if [ $remote_host != "$remote_shost" ]; then
		if [ -e "$remote_label:$remote_shost" ]; then
			mv $remote_label:$remote_shost $remote_label:$remote_host
		fi
		if [ -e "$remote_shost" ]; then
			mv $remote_shost $remote_host
		fi
	fi
	debug_log "[$script_name]completed: copying of tool data on $remote_host"
	debug_log "[$script_name]started: deleting tool data on $remote_host"
	ssh $ssh_opts -n $remote_host "cd $tool_dir && /bin/rm -rf *"
	debug_log "[$script_name]completed: deleting tool data on $remote_host"
	popd >/dev/null
}

function run_pp_job {
	local job_cmdfile=$1
	local job_cmdfile_output=$2
	local remote_host=$3
	local job_cmd="`cat $job_cmdfile`"
	debug_log "[$script_name]started: $job_cmd"
	if [ -z "$remote_host" ]; then
		$cmd_file 2>&1 | tee $cmd_file_output
	else
		$cmd_file 2>&1 | sed -e 's/\(.*\)/'[$remote]'\1/g' | tee $cmd_file_output
	fi
	debug_log "[$script_name]finished: $job_cmd"
}


### phase 1: generate data from tools

# tool postprocessing
# issue the postprocess command for each line in the tools file
while read this_line; do
	remote=""
	name=`echo $this_line | awk -F: '{print $1}'`
	if [ "$name" == "label" ]; then
		continue;
	fi
	options=`echo $this_line | awk -F: '{print $2}'`
	if echo $name | grep -q "@"; then
		# tool is on remote host
		remote=`echo $name | cut -d\@ -f2`
		# tool options are stored on the remote host's tool file, so no need to pass it here
		cmd="ssh $ssh_opts -n $remote postprocess-tools --iteration=$iteration --group=$group --dir=$dir"
		cmd_file="$cmd_dir/pbench@$remote-postprocess.cmd"
		cmd_file_output="$cmd_dir/pbench@$remote-postprocess-output.txt"
	else
		# tool is on local host
		cmd="$pbench_bin/tool-scripts/$name --postprocess --iteration=$iteration --group=$group --dir=$dir `grep ^$name $groupfile | cut -d: -f2- | sed -e 's/\"/\\\"/g'`"
		cmd_file="$cmd_dir/pbench-$name-postprocess.cmd"
		cmd_file_output="$cmd_dir/pbench-$name-postprocess-output.txt"
	fi
	debug_log "[$script_name]$cmd"
	echo $cmd >$cmd_file
	chmod +x $cmd_file
	run_pp_job $cmd_file $cmd_file_output $remote &
done <$groupfile
wait

# phase 2: now that the local results are ready, move them
# down to $tool_dir/[$label:]$hostname.
if grep -q -v "@" $groupfile; then
	pushd $tool_dir >/dev/null
	if grep -q "^label:" $groupfile; then
		label="`grep "^label:" $groupfile | awk -F: '{print $2}'`"
		mkdir "$label:$hostname"
		mv * "$label:$hostname" 2>/dev/null
	else
		mkdir -p $hostname
		mv * $hostname 2>/dev/null
	fi
	popd >/dev/null
fi

### phase 3: copy over data from remote hosts
# for the remote tools, copy over the postprocess data
while read this_line; do
	name=`echo $this_line | awk -F: '{print $1}'`
	options=`echo $this_line | awk -F: '{print $2}'`
	# this copies data from the remote host after it has completed its postprocessing
	if echo $name | grep -q "@"; then
		remote=`echo $name | cut -d\@ -f2`
		name=`echo $name | cut -d\@ -f1`
		label="$options" 
		# copy over the data from postprocessing
		move_tool_data $remote $label &
	fi
done <$groupfile
wait

debug_log "[$script_name]completed: $@"
