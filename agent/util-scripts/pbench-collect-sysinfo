#!/bin/bash

script_path=`dirname $0`
script_name=`basename $0`
pbench_bin="`cd ${script_path}/..; /bin/pwd`"

# source the base script
. "$pbench_bin"/base

pbench_log=${pbench_run}/pbench.log

# This script will collect sysinfo data from all registered
# tools hosts for a specific group. This is typically called
# at the beginning and end of a benchmark script to capture
# the configurations of all hosts involved in the benchmark.

# Defaults
group=default
dir="/tmp"

# always notify the user, as collection can sometimes take a while
echo "Collecting system information"

# Process options and arguments

opts=$(getopt -q -o d:g: --longoptions "dir:,group:" -n "getopt.sh" -- "$@");
if [ $? -ne 0 ]; then
	printf "\n"
	printf "$script_name: you specified an invalid option\n\n"
	printf "The following are required:\n\n"
	printf -- "\t-d str --dir=str, str = a directory where the $script_name\n"
	printf -- "\t                        will store and process data\n"
	printf "\n"
	printf -- "\t-g str --group=str, str = a tool group used in a benchmark\n"
	printf -- "\t                          (the default group is 'default')\n"
	printf "\n"
	exit 1
fi
eval set -- "$opts";
while true; do
	case "$1" in
		-g|--group)
		shift;
		if [ -n "$1" ]; then
			group="$1"
			shift;
		fi
		;;
		-d|--dir)
		shift;
		if [ -n "$1" ]; then
			dir="$1"
			shift;
		fi
		;;
		--)
		shift;
		break;
		;;
	esac
done

name="$1"
if [ -z "$name" ]; then
	error_log "Missing argument, need a name for this sysinfo collection, either \"beg\" or \"end\""
	exit 1
fi
if [ "$name" != "beg" -a "$name" != "end" ]; then
	error_log "Invalid argument, collection names should be either \"beg\" or \"end\", not \"$name\""
	exit 1
fi

# Make sure that the top-level directory exists no matter what
mkdir -p $dir
if [ ! -d $dir ]; then
	error_log "Unable to create working directory, $dir"
	exit 1
fi

# Ensure we have a tools group directory to work with
if [ -d "$pbench_run/tools-$group" ]; then
	tool_group_dir="$pbench_run/tools-$group"
else
	# Using the default group directory
	tool_group_dir="$pbench_run/tools-default"
	if [ ! -d "$tool_group_dir" ]; then
		error_log "Unable to find default tools group file, $tool_group_dir"
		exit 1
	fi
fi

sysinfo_path="$dir/sysinfo/$name"
if [ -d $sysinfo_path ]; then
	debug_log "Already collected sysinfo-dump data, named: $name; skipping..."
	exit 0
fi
mkdir -p $sysinfo_path
if [ ! -d $sysinfo_path ]; then
	error_log "Unable to create sysinfo-dump directory base path: $sysinfo_path"
	exit 1
fi

INVENTORY=/tmp/hosts.$$
pbench-get-hosts $tool_group_dir > ${INVENTORY}
trap "rm -f $INVENTORY" QUIT INT EXIT

function gather_remote_sysinfo_data {
        debug_log "gather_remote_sysinfo_data"
        echo "gathering remote sysinfo data"
        ansible-playbook -i ${INVENTORY} --extra-vars '{ "SYSINFO_PATH":"'$sysinfo_path'" }' /opt/pbench-agent/util-scripts/pbench-collect-sysinfo.yml &>>$pbench_log
}


## Collect the sysinfo-dumps in parallel

lcl_label=""
let lcl_cnt=0
for this_tool_file in `/bin/ls $tool_group_dir`; do
        if [ "$this_tool_file" == "label" ]; then
		let lcl_cnt=lcl_cnt+1
                continue;
        fi
        if echo "$this_tool_file" | grep -q "^remote"; then
		debug_log "gather_remote_sysinfo_data $remote_hostname $label"
	else
		# any other file is assumed to be a local tool
		let lcl_cnt=lcl_cnt+1
        fi
done
if /bin/ls "$tool_group_dir" | grep -q "^remote"; then
        gather_remote_sysinfo_data
fi

if [ $lcl_cnt -gt 0 ]; then
	# We found local tools, or a label, specified in the tools group
	# file, so we should collect sysinfo data locally
        debug_log "gather_local_sysinfo_data"
        echo "gathering local sysinfo data"
        ansible-playbook -i ${INVENTORY} --extra-vars '{ "SYSINFO_PATH":"'$sysinfo_path'" }' /opt/pbench-agent/util-scripts/pbench-collect-local-sysinfo.yml &>>$pbench_log
fi
wait

# collect the metadata for the run
pbench-metadata-log --group=$group --dir=$dir $name
status=$?

exit $status
