#!/bin/bash
# -*- mode: shell-script; indent-tabs-mode: t; sh-basic-offset: 8; sh-indentation: 8; sh-indent-for-case-alt: + -*-

script_path=`dirname $0`
script_name=`basename $0`
pbench_bin="`cd ${script_path}/..; /bin/pwd`"

# source the base script
. "$pbench_bin"/base

# This script will remove tools that have been registered.  If no
# options are used, then all tools from all tool groups are removed.
# Specifying a tool name and/or group will limit the scope of the
# removal.

function usage() {
    printf "usage:\n"
    printf "${script_name} [--help] <full path to tar ball> <results host> <results path prefix>\n"
	printf "The following are required:\n\n"
	printf -- "\t-g str --group=str, str = the group from which tools should be removed\n"
	printf -- "\t                          (the default group is 'default')\n"
	printf -- "\t-n str --name=str, str = a specific tool to be removed.  If no tool is specified, all tools in the group are removed\n"
	printf -- "\t-n str --remote=str, str = a specific remote on which tools needs to be cleared.  If no remote is specified, all the tools are removed\n\n"
}

# Process options and arguments
opts=$(pbench-argparse -q -o g:n:r:h --longoptions "group:,name:,remote:,help" -n "${script_name}" -- "${@}")
sts=${?}
if [[ ${sts} -ne 0 ]]; then
    printf -- "\n" >&2
    usage >&2
	exit ${sts}
fi

# Defaults
name=""
group="default"

eval set -- "${opts}"
while true; do
    opt="${1}"
    shift
    case "${opt}" in
	-n|--name)
	    if [[ -z "${1}" ]]; then printf -- "Logic bomb! empty argument for ${opt}\n" >&2; exit 100; fi
	    name="${1}"
	    shift
	    ;;
	-g|--group)
	    if [[ -z "${1}" ]]; then printf -- "Logic bomb! empty argument for ${opt}\n" >&2; exit 100; fi
	    group="${1}"
	    shift
	    ;;
	-r|--remote)
	    if [[ -z "${1}" ]]; then printf -- "Logic bomb! empty argument for ${opt}\n" >&2; exit 100; fi
            remote="${1}"
            shift
            ;;
	-h|--help)
	    usage
	    exit 0
	    ;;
	--)
	    break
	    ;;
	*)
	    printf "\n${script_name}: you specified an invalid option or provided an unexpected argument: \"${opt}\"\n\n" >&2
	    usage >&2
	    exit 1
	    ;;
    esac
done

pushd $pbench_run >/dev/null
# this tool group's directory which stores options, etc.
tool_group_dir="tools-$group"
declare -a remotes
if [ -d "$tool_group_dir" ]; then
        for this_tool_file in `/bin/ls $tool_group_dir`; do
                    remotes[${#remotes[@]}]=$this_tool_file
        done
fi
if [ ! -z "$remote" ]; then
	for ((i=0; i<${#remotes[*]}; i++));do
		if [[ ${remotes[i]} == remote@$remote ]]; then
			unset remotes[@]
			remotes[${#remotes[@]}]=remote@$remote
                fi
	done
fi
typeset -i nerrs=0
ssh_opts="$ssh_opts -o ConnectTimeout=1"
for ((i=0; i<${#remotes[*]}; i++));do
        # if there is a remote tool, call clear tools on the remote host
        this_tool_file=${remotes[i]}
        if [ "$this_tool_file" == "label" ]; then
		continue;
        fi
        if echo $this_tool_file | grep -q "^remote"; then
		group_opt="--group $group"
        	if [ ! -z "$name" ]; then
        	  name_opt="--name=$name"
              	fi
         	remote_hostname=`echo $this_tool_file | awk -F@ '{print $2}'`
         	echo running ". ${pbench_install_dir}/profile; pbench-clear-tools $group_opt $name_opt" on $remote_hostname
        	ssh $ssh_opts -n $remote_hostname ". ${pbench_install_dir}/profile; pbench-clear-tools $group_opt $name_opt" | sed -e 's/\(.*\)/['$remote_hostname']\1/g'
         	rc=$?
        	if [ $rc != 0 ] ;then
        		nerrs=$nerrs+1
          		# we can't get to the remote but if the intent is to clear all tools
           		# then we remove the local entry for the remote
                	if [ -z "$name" ] ;then
              			echo "Removing the remote $this_tool_file"
             			 /bin/rm -f "$tool_group_dir/$this_tool_file"
           		fi
		    	continue
        	fi
          	remaining_remote_tools=`ssh $ssh_opts -n $remote_hostname ". ${pbench_install_dir}/profile; pbench-list-tools $group_opt"`
                if [ -z "$remaining_remote_tools" ]; then
        		echo "The remote host $remote_hostname no longer has tools registered for $group group, so the "remote@$remote" entry in the local $tool_group_dir directory will be removed"
             		echo "/bin/rm -f $tool_group_dir/$this_tool_file"
             		/bin/rm -f "$tool_group_dir/$this_tool_file"
                fi
        else
        	# remove any existing local entry for this tool
        	# if a tool name was provided, only remove that tool.  If not, all tools should be removed
        	if [ -z "$name" -o "$name" == "$this_tool_file" ]; then
	        	echo "removing $tool_group_dir/$this_tool_file"
            		/bin/rm -rf "$tool_group_dir/$this_tool_file"
          	fi
        fi
done
tool_files=`/bin/ls $tool_group_dir`
# if the only file remaining is the label, remove it
if [ "$tool_files" == "label" ]; then
	echo "removing tool label: `cat $tool_group_dir/$tool_files`"
	/bin/rm -f "$tool_group_dir/$tool_files"
fi
popd >/dev/null
exit $nerrs
