#!/usr/bin/env python3
# -*- mode: python -*-

"""pbench-tool-meister-start

Responsible for orchestrating the Redis Server, Tool Data Sink (TDS), and Tool
Meisters (TMs):

   1. Loading tool group data for the requested tool group
   2. Starting a Redis server and creating the Redis channel for the TDS to
      talk to the client
      - <prefix>-to-client
      - TDS publishes, a client subscribes
      - This is how TDS tells a client the success or failure of the actions
   3. Pushing the loaded tool group data and metadata into the Redis server
   4. Starting the Tool Data Sink process
   5. Starting all the local and remote Tool Meisters
   6. Waiting for the TDS to send a message reporting that it, and all the TMs
      started
      - The TDS knows all the TMs that were started from the registered tools
        data structure argument

There is a specific flow of data between these various components.  This
command, `pbench-tool-meister-start`, waits on the "<prefix>-to-client"
channel after starting the TDS and TMs.  The Tool Data Sink is responsible for
creating and subscribing to the "<prefix>-from-tms" channel to wait for all
the TMs to report in.  The TMs create and subscribe to the "<prefix>-to-tms"
channel waiting for their first command.  The TMs then publish they are ready
on the "<prefix>-from-tms" channel. Once the TDS sees all the expected TMs, it
writes a set of combined metadata about all the TMs, along with the (optional)
external metadata passed to it on startup, to the local "metadata.log" file in
the "${benchmark_run_dir}".  It then tells this command the combined success /
failure of its startup and that of the TMs via the "<prefix>-to-client"
channel.

Summary of the other Redis pub/sub channels:

   1. "<prefix>-to-client" channel for the TDS to talk to a client
      - a client subscribes, the TDS publishes
      - This is used by the TDS to report success or failure of an action to
        a client

   2. "<prefix>-from-client" channel for a client to talk to the TDS
      - TDS subscribes, a client publishes
      - This is used to send the various actions from the client to the TDS

   3. "<prefix>-to-tms" channel for the TDS to talk to TMs
       - TMs subscribe, TDS publishes
       - This is how the TDS forwards actions to the TMs

   4. "<prefix>-from-tms" channel for TMs to talk to the TDS
       - TMs publish, TDS subscribes
       - This is how TMs tell the TDS the success or failure of their actions

Once a success message is received by this command from the TDS, the following
steps are taken as a normal client:

   1. Collect any requested system information ("sysinfo" action)
   2. Start any persistent tools running ("init" action)

We then leave running, locally, a Redis server, a Tool Data Sink process,
and any local or remote Tool Meisters.

The pbench-tool-meister-stop command will take care of (gracefully) stopping
all of these processes, locally or remotely.

"""

import errno
import json
import logging
import os
import shlex
import signal
import socket
import sys
import time

from argparse import ArgumentParser
from distutils.spawn import find_executable
from pathlib import Path

import redis

from pbench.agent.constants import (
    def_redis_port,
    cli_tm_channel_prefix,
    tm_channel_suffix_to_client,
    tm_channel_suffix_from_client,
    tm_channel_suffix_to_logging,
)
from pbench.agent.redis import RedisChannelSubscriber
from pbench.agent.tool_data_sink import main as tds_main
from pbench.agent.tool_group import BadToolGroup, ToolGroup
from pbench.agent.tool_meister import main as tm_main
from pbench.agent.tool_meister_client import Client
from pbench.agent.toolmetadata import ToolMetadata
from pbench.agent.utils import cli_verify_sysinfo, error_log, info_log


# Redis server configuration template for pbench's use
redis_conf_tmpl = """bind {hostnames}
daemonize yes
dir {tm_dir}
dbfilename pbench-redis.rdb
logfile {tm_dir}/redis.log
loglevel notice
pidfile {tm_dir}/redis_{redis_port:d}.pid
port {redis_port:d}
"""


def wait_for_tds(chan, logger):
    """wait_for_tds - Wait for the Tool Data Sink to report back success or
    failure regarding the Tool Meister environment setup.
    """
    status = ""
    for data in chan.fetch_json(logger):
        # We expect the payload to look like:
        #   { "kind": "ds",
        #     "action": "startup",
        #     "status": "success|failure"
        #   }
        try:
            kind = data["kind"]
            action = data["action"]
            status = data["status"]
        except KeyError:
            logger.warning("unrecognized data payload in message, '%r'", data)
            continue
        else:
            if kind != "ds":
                logger.warning("unrecognized kind field in message, '%r'", data)
                continue
            if action != "startup":
                logger.warning("unrecognized action field in message, '%r'", data)
                continue
            break
    return 0 if status == "success" else 1


class ReturnCode:
    """ReturnCode - symbolic return codes for the main program of
    pbench-tool-meister-start.
    """

    SUCCESS = 0
    BADTOOLGROUP = 1
    BADAGENTCONFIG = 2
    MISSINGINSTALLDIR = 4
    EXCINSTALLDIR = 5
    BADTOOLMETADATA = 6
    MISSINGREQENVS = 7
    EXCCREATETMDIR = 8
    MISSINGHOSTNAMEENVS = 9
    NOIP = 10
    EXCREDISCONFIG = 11
    EXCSPAWNREDIS = 12
    REDISFAILED = 13
    REDISCHANFAILED = 14
    REDISTMKEYFAILED = 15
    REDISTDSKEYFAILED = 16
    TDSFORKFAILED = 17
    TDSLOGPUBFAILED = 18
    TMFAILURES = 19
    TMNOSUCCESSES = 20
    TDSWAITFAILURE = 21
    EXCSYSINFODIR = 22
    EXCTOOLGROUPDIR = 23
    SYSINFOFAILED = 24
    INITFAILED = 25
    TDSSTARTUPTIMEOUT = 26
    TOOLGROUPEXC = 27
    BADREDISARG = 28
    BADREDISPORT = 29

    # Kill sub-codes
    KILL_SUCCESS = 0
    KILL_READEXC = 1
    KILL_BADPID = 2
    KILL_PIDNOTFOUND = 3
    KILL_KILLERR = 4
    KILL_KILLEXC = 5

    @staticmethod
    def kill_ret_code(kill_code, ret_val):
        """kill_ret_code - return an integer return code made up of the given
        kill code and a return value.

        A kill code of 0 and return value of 42 is returned as 42.
        A kill code of 5 and return value of 52 is returned as 542.
        """
        return (kill_code * 100) + ret_val


def kill_redis_server(pid_file, ret_val):
    """kill_redis_server - given a redis server PID file, attempt to KILL the
    Redis server.

    Returns "1" if successfully KILL'd; "2" if it encounters an error reading
    the PID file; "3" if bad PID value; "4" if the Redis server PID does not
    exist; "5" if some kind of OSError is encountered; and "6" if some other
    exception was encountered while KILL'ing it.
    """
    try:
        raw_pid = pid_file.read_text()
    except Exception:
        # No "pid" to kill
        return ReturnCode.kill_ret_code(ReturnCode.KILL_READEXC, ret_val)
    else:
        try:
            pid = int(raw_pid)
        except ValueError:
            # Bad pid value
            return ReturnCode.kill_ret_code(ReturnCode.KILL_BADPID, ret_val)
        try:
            os.kill(pid, signal.SIGKILL)
        except OSError as exc:
            if exc.errno == errno.ESRCH:
                # PID not found, ignore
                return ReturnCode.kill_ret_code(ReturnCode.KILL_PIDNOTFOUND, ret_val)
            else:
                # Some error encountered trying to KILL the process.
                return ReturnCode.kill_ret_code(ReturnCode.KILL_KILLERR, ret_val)
        except Exception:
            # Some other error encountered trying to KILL the process.
            return ReturnCode.kill_ret_code(ReturnCode.KILL_KILLEXC, ret_val)
        else:
            # "successfully" KILL'd the give process.
            return ReturnCode.kill_ret_code(ReturnCode.KILL_SUCCESS, ret_val)


def waitpid(pid):
    """Wrapper for os.waitpid()

    Returns the exit status of the given process ID.

    Raises an exception if the final exit PID is different from the given PID.
    """
    exit_pid, _exit_status = os.waitpid(pid, 0)
    if pid != exit_pid:
        raise Exception(f"Logic bomb!  exit pid, {exit_pid}, does not match pid, {pid}")
    exit_status = os.WEXITSTATUS(_exit_status)
    return exit_status


def main(_prog, cli_params):
    """Main program for the tool meister start.

    :cli_params: expects a CLI parameters object which has two attributes:

        * tool_group - The tool group from which to load the registered tools
        * sysinfo    - The system information set to be collected at the start

    Return 0 on success, non-zero ReturnCode class value on failure.
    """
    PROG = Path(_prog)
    logger = logging.getLogger(PROG.name)
    if os.environ.get("_PBENCH_TOOL_MEISTER_START_LOG_LEVEL") == "debug":
        log_level = logging.DEBUG
    else:
        log_level = logging.INFO
    logger.setLevel(log_level)
    sh = logging.StreamHandler()
    sh.setLevel(log_level)
    shf = logging.Formatter("%(message)s")
    sh.setFormatter(shf)
    logger.addHandler(sh)

    # +
    # Step 1 - Load the tool group data for the requested tool group
    # -

    # Verify all the command line arguments
    group = cli_params.tool_group
    try:
        # Load the tool group data
        tool_group = ToolGroup(group)
    except BadToolGroup as exc:
        logger.error(str(exc))
        return ReturnCode.BADTOOLGROUP
    except Exception:
        logger.exception("failed to load tool group data for '%s'", group)
        return ReturnCode.TOOLGROUPEXC
    else:
        if not tool_group.hostnames:
            # If a tool group has no tools registered, then there will be no
            # host names on which to start Tool Meisters.
            return ReturnCode.SUCCESS

    sysinfo, bad_l = cli_verify_sysinfo(cli_params.sysinfo)
    if bad_l:
        logger.error('invalid sysinfo option(s), "{}"', ",".join(bad_l))

    # Load the tool metadata
    try:
        inst_dir = os.environ["pbench_install_dir"]
    except KeyError:
        logger.error(
            "The required 'pbench_install_dir' environment variable appears to be missing"
        )
        return ReturnCode.BADAGENTCONFIG
    try:
        tm_start_path = Path(inst_dir).resolve(strict=True)
    except FileNotFoundError:
        logger.error(
            "Unable to determine proper installation directory, '%s' not found",
            inst_dir,
        )
        return ReturnCode.MISSINGINSTALLDIR
    except Exception as exc:
        logger.exception(
            "Unexpected error encountered resolving installation directory: '%s'", exc,
        )
        return ReturnCode.EXCINSTALLDIR
    else:
        try:
            tool_metadata = ToolMetadata(tm_start_path)
        except Exception:
            logger.exception("failed to load tool metadata")
            return ReturnCode.BADTOOLMETADATA

    # Load and verify required and optional environment variables.
    try:
        benchmark_run_dir = Path(os.environ["benchmark_run_dir"]).resolve(strict=True)
        hostname = os.environ["_pbench_hostname"]
        full_hostname = os.environ["_pbench_full_hostname"]
    except Exception:
        logger.exception("failed to fetch parameters from the environment")
        return ReturnCode.MISSINGREQENVS
    else:
        tm_dir = benchmark_run_dir / "tm"
        try:
            tm_dir.mkdir()
            os.chdir(tm_dir)
        except Exception:
            logger.exception("failed to create the local tool meister directory")
            return ReturnCode.EXCCREATETMDIR
        if not full_hostname or not hostname:
            logger.error(
                "ERROR - _pbench_hostname ('%s') and _pbench_full_hostname ('%s')"
                " environment variables are required to represent the respective"
                " hostname strings",
                hostname,
                full_hostname,
            )
            return ReturnCode.MISSINGHOSTNAMEENVS

    # See if anybody told us to use certain options with SSH commands.
    ssh_opts = os.environ.get("ssh_opts", "")

    # Load optional metadata environment variables
    optional_md = dict(
        script=os.environ.get("benchmark", ""),
        config=os.environ.get("config", ""),
        date=os.environ.get("date", ""),
        ssh_opts=ssh_opts,
    )

    # Determine the Tool Meister "hostname" to use for the Redis server to
    # bind to, in addition to "localhost". That same host name will be used by
    # the Tool Data Sink to bind to as well.  If the caller's environment
    # contains a PBENCH_TM_BIND_HOSTNAME environment variable, we'll use that,
    # if not, we'll use the value from the _pbench_full_hostname environment
    # variable.
    tm_bind_hostname = os.environ.get("PBENCH_TM_BIND_HOSTNAME", full_hostname)
    hostnames_l = []
    try:
        localhost_ip = socket.gethostbyname("localhost")
    except socket.error:
        # Interesting networking environment, no IP address for "localhost" ...
        localhost_ip = None
    else:
        # Add to the list of host names the Redis server will use.
        hostnames_l.append("localhost")
    try:
        tm_bind_hostname_ip = socket.gethostbyname(tm_bind_hostname)
    except socket.error:
        # The given Tool Meister host name does not map to an IP address, so
        # we can't use it.
        if localhost_ip is None:
            logger.error(
                "No available host names have usable IP addresses! (checked"
                ' "localhost", "%s", and "%s"',
                full_hostname,
                tm_bind_hostname,
            )
            return ReturnCode.NOIP
        assert (
            "localhost" in hostnames_l
        ), f"Logic Bomb! localhost does not map to an IP"
        tm_bind_hostname = "localhost"
    else:
        assert (
            tm_bind_hostname_ip is not None
        ), "Logic Bomb!  socket.gethostbyname() return None"
        if tm_bind_hostname_ip != localhost_ip:
            assert (
                tm_bind_hostname != "localhost"
            ), f"Logic Bomb! tm_bind_hostname ({tm_bind_hostname:r}) == 'localhost'?"
            # The Tool Meister host name is not the same as "localhost" so we
            # can add it to the list of host names the Redis server will use.
            hostnames_l.append(tm_bind_hostname)
        else:
            assert (
                "localhost" in hostnames_l
            ), f"Logic Bomb! localhost does not map to an IP"
            # Whatever the tm_bind_hostname was it maps to the same IP address as
            # localhost, so just use "localhost" for the Tool Meister host
            # name.
            tm_bind_hostname = "localhost"
    hostnames = " ".join(hostnames_l)

    # +
    # Step 2. - Start the Redis Server
    # -
    if cli_params.redis_server is None:
        # Create the Redis server pbench-specific configuration file
        redis_conf = tm_dir / "redis.conf"
        params = {
            "hostnames": hostnames,
            "tm_dir": tm_dir,
            "redis_port": def_redis_port,
        }
        try:
            with redis_conf.open("w") as fp:
                fp.write(redis_conf_tmpl.format(**params))
        except Exception:
            logger.exception("failed to create redis server configuration")
            return ReturnCode.EXCREDISCONFIG

        # Start the Redis Server itself
        redis_srvr = "redis-server"
        redis_srvr_path = find_executable(redis_srvr)
        redis_pid = tm_dir / f"redis_{def_redis_port:d}.pid"
        logger.debug("2. starting redis server")
        try:
            retcode = os.spawnl(os.P_WAIT, redis_srvr_path, redis_srvr, redis_conf)
        except Exception:
            logger.exception("failed to create redis server, daemonized")
            return ReturnCode.EXCSPAWNREDIS
        else:
            if retcode != 0:
                logger.error(
                    "failed to create redis server, daemonized; return code: %d",
                    retcode,
                )
                return ReturnCode.REDISFAILED
        redis_host = "localhost"
        redis_port = def_redis_port
    else:
        parts = cli_params.redis_server.split(":", 1)
        if len(parts) != 2:
            logger.error("Bad Redis server specified, '%s'", cli_params.redis_server)
            return ReturnCode.BADREDISARG
        try:
            redis_port = int(parts[1])
        except ValueError:
            logger.error("Bad Redis port specified, '%s'", cli_params.redis_server)
            return ReturnCode.BADREDISPORT
        else:
            redis_host = parts[0]

    # Connect to the Redis Server.
    #
    # It is not sufficient to just create the Redis() object, we have to
    # initiate some operation with the Redis Server. We use the creation of the
    # "<prefix>-to-client" channel for that purpose. We'll be acting as a
    # client later on, so we subscribe to the "<prefix>-to-client" channel to
    # listen for responses from the Tool Data Sink.
    try:
        to_client_channel = f"{cli_tm_channel_prefix}-{tm_channel_suffix_to_client}"
        redis_server = redis.Redis(host=redis_host, port=redis_port, db=0)
        to_client_chan = RedisChannelSubscriber(redis_server, to_client_channel)
    except Exception as exc:
        logger.error(
            "Unable to connect to redis server, %s:%d: %r", redis_host, redis_port, exc
        )
        return kill_redis_server(redis_pid, ReturnCode.REDISCHANFAILED)

    # +
    # 3. Push the loaded tool group data and metadata into the Redis server
    # -
    logger.debug("3. push tool group data and metadata")
    tool_group_data = dict()
    for host in tool_group.hostnames.keys():
        tools = tool_group.get_tools(host)
        if host == full_hostname:
            _controller = full_hostname
        else:
            _controller = (
                "localhost" if os.environ.get("_PBENCH_UNIT_TESTS") else full_hostname
            )
        tm = dict(
            benchmark_run_dir=str(benchmark_run_dir),
            channel_prefix=cli_tm_channel_prefix,
            controller=_controller,
            group=group,
            hostname=host,
            label=tool_group.get_label(host),
            tool_metadata=tool_metadata.getFullData(),
            tools=tools,
        )
        # Create a separate key for the Tool Meister that will be on that host
        #
        # FIXME: we ought to support tool registration by label, and label
        # host names instead.
        tm_param_key = f"tm-{group}-{host}"
        try:
            redis_server.set(tm_param_key, json.dumps(tm, sort_keys=True))
        except Exception:
            logger.exception(
                "failed to create tool meister parameter key in redis server"
            )
            return kill_redis_server(redis_pid, ReturnCode.REDISTMKEYFAILED)
        tool_group_data[host] = tools

    # Create the key for the Tool Data Sink
    # FIXME: if only one host and it is local, don't bother with the Tool Data
    # Sink.
    tds_param_key = f"tds-{group}"
    tds = dict(
        benchmark_run_dir=str(benchmark_run_dir),
        bind_hostname=tm_bind_hostname,
        channel_prefix=cli_tm_channel_prefix,
        group=group,
        tool_metadata=tool_metadata.getFullData(),
        tool_trigger=tool_group.trigger,
        tools=tool_group_data,
        # The following are optional
        optional_md=optional_md,
    )
    try:
        redis_server.set(tds_param_key, json.dumps(tds, sort_keys=True))
    except Exception:
        logger.exception(
            "failed to create tool data sink parameter key in redis server"
        )
        return kill_redis_server(redis_pid, ReturnCode.REDISTDSKEYFAILED)

    # +
    # 4. Start the Tool Data Sink process
    # -

    if cli_params.redis_server is None:
        # FIXME: if only one host is registered, and that host is the same as this
        # controller, then don't bother starting the Tool Data Sink.
        logger.debug("4. starting tool data sink")
        try:
            pid = os.fork()
            if pid == 0:
                # In the child!

                # The main() of the Tool Data Sink module will not return here
                # since it will daemonize itself and this child pid will be
                # replaced by a new pid.
                status = tds_main(
                    [
                        PROG.parent / "tool-meister" / "pbench-tool-data-sink",
                        "localhost",
                        str(redis_port),
                        tds_param_key,
                        "yes",  # Request tool-data-sink daemonize itself
                    ]
                )
                sys.exit(status)
            else:
                # In the parent!

                # Wait for the child to finish daemonizing itself.
                retcode = waitpid(pid)
                if retcode != 0:
                    logger.error(
                        "failed to create pbench data sink, daemonized; return code: %d",
                        retcode,
                    )
        except Exception:
            logger.exception("failed to create pbench data sink, daemonized")
            return kill_redis_server(redis_pid, ReturnCode.TDSFORKFAILED)
        else:
            # Wait for logging channel to be up and ready before we start the
            # local and remote Tool Meisters.
            timeout = time.time() + 60
            num_present = 0
            while num_present == 0:
                try:
                    num_present = redis_server.publish(
                        f"{cli_tm_channel_prefix}-{tm_channel_suffix_to_logging}",
                        "pbench-tool-meister-start - verify logging channel up",
                    )
                except Exception:
                    logger.exception(
                        "Failed to verify Tool Data Sink logging sink working"
                    )
                    return kill_redis_server(redis_pid, ReturnCode.TDSLOGPUBFAILED)
                else:
                    if num_present == 0:
                        if time.time() > timeout:
                            logger.error(
                                "The Tool Data Sink failed to start within one minute"
                            )
                            return kill_redis_server(
                                redis_pid, ReturnCode.TDSSTARTUPTIMEOUT
                            )
                        else:
                            time.sleep(0.1)

    # +
    # 5. Start all the local and remote Tool Meisters
    # -

    if cli_params.redis_server is None:
        failures = 0
        successes = 0
        # NOTE: it is assumed that the location of the pbench-tool-meister command
        # is the same on the local host as it is on any remote host.
        tool_meister_cmd = PROG.parent / "tool-meister" / "pbench-tool-meister"
        ssh_cmd = "ssh"
        ssh_path = find_executable(ssh_cmd)
        base_args = [
            ssh_cmd,
        ]
        base_args.extend(shlex.split(ssh_opts))
        args = [
            "<host replace me>",
            f"{tool_meister_cmd}-remote",
            tm_bind_hostname,
            str(redis_port),
            "<tm param key>",
            "yes",  # Yes, request the tool meister daemonize itself
        ]
        tms = dict()
        tm_count = 0
        for host in tool_group.hostnames.keys():
            tm_count += 1
            tm_param_key = f"tm-{group}-{host}"
            if host == full_hostname:
                logger.debug("5a. starting localhost tool meister")
                try:
                    pid = os.fork()
                    if pid == 0:
                        # In the child!

                        # The main() of the Tool Meister module will not return
                        # here since it will daemonize itself and this child pid
                        # will be replaced by a new pid.
                        status = tm_main(
                            [
                                str(tool_meister_cmd),
                                "localhost",
                                str(redis_port),
                                tm_param_key,
                                "yes",  # Yes, daemonize yourself TM ...
                            ]
                        )
                        sys.exit(status)
                    else:
                        # In the parent!
                        pass
                except Exception:
                    logger.exception(
                        "failed to create localhost tool meister, daemonized"
                    )
                    failures += 1
                    tms[host] = {"pid": None, "status": "failed"}
                else:
                    # Record the child pid to wait below.
                    tms[host] = {"pid": pid, "status": "forked"}
            else:
                args[0] = host
                args[4] = tm_param_key
                ssh_args = base_args + args
                logger.debug(
                    "5b. starting remote tool meister, ssh_path=%r ssh_args=%r",
                    ssh_path,
                    ssh_args,
                )
                try:
                    pid = os.spawnv(os.P_NOWAIT, ssh_path, ssh_args)
                except Exception:
                    logger.exception(
                        "failed to create a tool meister instance for host %s", host
                    )
                    tms[host] = {"pid": None, "status": "failed"}
                else:
                    # Record the child pid to wait below.
                    tms[host] = {"pid": pid, "status": "spawned"}

        for host, tm_proc in tms.items():
            if tm_proc["status"] == "failed":
                failures += 1
                continue
            pid = tm_proc["pid"]
            try:
                exit_status = waitpid(pid)
            except Exception:
                failures += 1
                logger.exception(
                    "failed to create a tool meister instance for host %s", host
                )
            else:
                if exit_status != 0:
                    failures += 1
                    logger.error(
                        "failed to start tool meister on remote host '%s'"
                        " (pid %d), exit status: %d",
                        host,
                        pid,
                        exit_status,
                    )
                else:
                    successes += 1

        if failures > 0:
            # Don't wait for the Tool Meisters
            logger.info("terminating tool meister startup due to failures")
            terminate_msg = dict(action="terminate", group=group, directory=None)
            try:
                ret = redis_server.publish(
                    f"{cli_tm_channel_prefix}-{tm_channel_suffix_from_client}",
                    json.dumps(terminate_msg, sort_keys=True),
                )
            except Exception:
                logger.exception("Failed to publish terminate message")
            else:
                logger.debug("publish('terminate') = %r", ret)
            return kill_redis_server(redis_pid, ReturnCode.TMFAILURES)

        if successes == 0:
            logger.warning(
                "unable to successfully start any tool meisters,"
                " but encountered no failures either: terminating"
            )
            return kill_redis_server(redis_pid, ReturnCode.TMNOSUCCESSES)

        assert successes == tm_count, (
            f"Logic Bomb! Number of created Tool Meisters, {successes}, does not"
            f" match the expected number of Tool Meisters, {tm_count}"
        )

    # +
    # 6. Wait for the TDS to send a message reporting that it, and all the
    # TMs, started.
    # -

    # If any successes, then we need to wait for them to show up as
    # subscribers.
    logger.debug(
        "6. waiting for all successfully created Tool Meister processes"
        " to show up as subscribers"
    )
    ret_val = wait_for_tds(to_client_chan, logger)
    if ret_val != 0:
        if cli_params.redis_server is None:
            # We created the Redis server, so we should clean it up.
            return kill_redis_server(redis_pid, ReturnCode.TDSWAITFAILURE)
        else:
            return ReturnCode.TDSWAITFAILURE

    # Setup a Client API object using our existing to_client_chan object to
    # drive the following client operations ("sysinfo" [optional] and "init"
    # [required]).
    with Client(
        redis_server=redis_server,
        channel_prefix=cli_tm_channel_prefix,
        to_client_chan=to_client_chan,
        logger=logger,
    ) as client:
        if sysinfo:
            sysinfo_path = benchmark_run_dir / "sysinfo" / "beg"
            try:
                sysinfo_path.mkdir(parents=True)
            except Exception:
                error_log(
                    f"Unable to create sysinfo-dump directory base path: {sysinfo_path}"
                )
            else:
                logger.debug("7. Collecting system information")
                info_log("Collecting system information")
                # Collecting system information is optional, so we don't gate
                # the success or failure of the startup on it.
                client.publish(group, sysinfo_path, "sysinfo", sysinfo)

        tool_dir = benchmark_run_dir / f"tools-{group}"
        try:
            tool_dir.mkdir(exist_ok=True)
        except Exception as exc:
            error_log(f"failed to create tool output directory, '{tool_dir}': {exc}")
            return ReturnCode.EXCTOOLGROUPDIR
        else:
            logger.debug("8. Initialize persistent tools")
            ret_val = client.publish(group, tool_dir, "init", None)
            if ret_val != 0:
                if cli_params.redis_server is None:
                    # We created the Redis server, so we should clean it up.
                    ret_val = kill_redis_server(redis_pid, ReturnCode.INITFAILED)
    return ret_val


_NAME_ = "pbench-tool-meister-start"

if __name__ == "__main__":
    parser = ArgumentParser(
        f"Usage: {_NAME_} [--sysinfo <list of system information items>]"
    )
    parser.add_argument(
        "--sysinfo",
        dest="sysinfo",
        default=None,
        help="The list of system information items to be collected.",
    )
    parser.add_argument(
        "--redis-server",
        dest="redis_server",
        default=os.environ.get("PBENCH_REDIS_SERVER", None),
        help=(
            "Use an existing Redis server specified by <hostname>:<port>;"
            " implies an existing Tool Data Sink and Tool Meisters as well."
        ),
    )
    parser.add_argument(
        "tool_group",
        help="The tool group name of tools to be run by the Tool Meisters.",
    )
    parsed = parser.parse_args()
    status = main(sys.argv[0], parsed)
    sys.exit(status)
