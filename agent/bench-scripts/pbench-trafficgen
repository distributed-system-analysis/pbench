#!/bin/bash
# -*- mode: shell-script; indent-tabs-mode: t; sh-basic-offset: 8; sh-indentation: 8; sh-indent-for-case-alt: + -*-

# Author: Andrew Theurer
#
# This is a script to run a network traffic generator like MoonGen or TRex.
# It is intended to test a network function, like a bridge or router.
# 
# Hardware prerequisites:
# - A Linux host with 1 to 2 network adapters.  These adapters must be either Intel XL710 or Intel 82599
#   Ideally this host should have x86-64 processors (current or previous generation) 1GB HW pages, and PCI-E v2 or v3
# - A "device-under-test" (DUT) which network traffic will pass through.
#   The DUT will need to be configured to pass traffic before running this benchmark script
#

# This script attempts to automate potentially a very large number of tests
# This script will take multiple samples of the same test type and try to achieve a standard deviation of <3%
# This script will repeat a test type 6 times in order to try to achieve target stddev.
# If a run (with several samples) fails the stddev, its directory is appended with -fail
# This script will also generate a "results.txt" with a table of all
# results, efficiency, and other stats.

pbench_cmd="$@"
script_path=`dirname $0`
script_name=`basename $0`
pbench_bin="`cd ${script_path}/..; /bin/pwd`"
benchmark_name="trafficgen"
trafficgen_dir="/opt/lua-trafficgen"
# source the base script
. "$pbench_bin"/base

# Every bench-script follows a similar sequence:
# 1) process bench script arguments
# 2) ensure the right version of the benchmark is installed
# 3) gather pre-run state
# 4) run the benchmark and start/stop perf analysis tools
# 5) gather post-run state
# 6) postprocess benchmark data
# 7) postprocess analysis tool data

# Defaults
traffic_generator="trex-txrx" # can be either trex-txrx or moongen-txrx
trex_use_ht="n"
trex_use_l2="n"
benchmark_run_dir=""
traffic_directions="bidirec"
max_loss_pcts="0.002"
num_flows="1024"
num_samples=1
rates="none"
rate_tolerance_pct=3 # by percent, how much the TX rate can vary from desired rate
rate_unit="mpps"
devices="" # the network devices as PCI location IDs, like "0000:04:00.0,0000:04:00.1"
active_devices="" # the active network devices as PCI location IDs, like "0000:04:00.0,0000:04:00.1"
dst_ips=""
src_ips=""
dst_macs=""
src_macs=""
encap_dst_ips=""
encap_src_ips=""
encap_dst_macs=""
encap_src_macs=""
frame_sizes="64" # size in bytes of the Ethernet frame inccluding CRC
config=""
maxstddevpct=5 # maximum allowable standard deviation in percent
max_failures=1 # after N failed attempts to hit below $maxstddevpct, move on to the nest test
df_sniff_runtime=30
df_search_runtime=120
df_validation_runtime=300
df_zl_sniff_runtime=30
df_zl_search_runtime=1200
df_zl_validation_runtime=7200
postprocess_only=n
start_iteration_num=1
keep_failed_tool_data="y"
tar_nonref_data="n"
orig_cmd="$*"
tool_group=default
install_only="n"
one_shot="n"
skip_trex_install="n"
skip_trex_server="n"
skip_git_pull="n"
flow_mods="src-ip,dst-ip,src-mac,dst-mac"
all_possible_flow_mods="src-ip,dst-ip,src-mac,dst-mac,src-port,dst-port,encap-src-ip,encap-dst-ip,encap-src-mac,encap-dst-mac,protocol,none"
cmd="./binary-search.py"
packet_protocol="UDP"

function kill_trex() {
	# kill any existing trex server process
	trex_pids=$(netstat -tanp | grep -E :4500\|:4501 | awk '{print $7}' | awk -F/ '{print $1}' | grep -v -- "-" | sort | uniq)
	if [ ! -z "$trex_pids" ]; then
		echo "killing existing trex server"
		kill ${trex_pids}
		sleep 5
	fi
}

function convert_number_range() {
        # converts a range of cpus, like "1-3,5" to a list, like "1,2,3,5"
        local cpu_range=$1
        local cpus_list=""
        local cpus=""
        for cpus in `echo "$cpu_range" | sed -e 's/,/ /g'`; do
                if echo "$cpus" | grep -q -- "-"; then
                        cpus=`echo $cpus | sed -e 's/-/ /'`
                        cpus=`seq $cpus | sed -e 's/ /,/g'`
                fi
                for cpu in $cpus; do
                        cpus_list="$cpus_list,$cpu"
                done
        done
        cpus_list=`echo $cpus_list | sed -e 's/^,//'`
        echo "$cpus_list"
}

# Process options and arguments
opts=$(getopt -q -o c: --longoptions "skip-trex-install,skip-trex-server,skip-git-pull,traffic-generator:,devices:,active-devices:,rate-unit:,rate:,rates:,rate-tolerance-pct:,max-loss-pct:,max-loss-pcts:,install,start-iteration-num:,config:,num-flows:,test-type:,traffic-direction:,traffic-directions:,sniff-runtime:,search-runtime:,validation-runtime:,frame-size:,frame-sizes:,samples:,max-stddev:,max-failures:,postprocess-only:,run-dir:,tool-group:,one-shot,src-ports:,dst-ports:,src-macs:,src-ips:,dst-macs:,dst-ips:,encap-src-macs:,encap-src-ips:,encap-dst-macs:,encapdst-ips:,vlan-ids:,overlay-ids:,overlay-types:,flow-mods:,packet-protocol:,trex-use-ht,trex-use-l2" -n "getopt.sh" -- "$@")
if [ $? -ne 0 ]; then
	printf -- "$*\n"
	printf "\n"
	printf "\t${benchmark_name}: you specified an invalid option\n\n"
	printf "\tThe following options are available:\n\n"
	#                   1         2         3         4         5         6         7         8
	#          12345678901234567890123456789012345678901234567890123456789012345678901234567890
	printf -- "\n"
	printf -- "trafficgen general test options\n"
	printf -- "-------------------------------\n"
	printf -- "\n"
	printf -- "--traffic-generator=str\n"
	printf -- "  The traffic generation engine to use (trex-txrx or moongen-txrx)\n"
	printf -- "  Default is $traffic_generator\n"
	printf -- "\n"
	printf -- "--devices=str,str\n"
	printf -- "  List of 2 (or more) DPDK devices to use, by PCI location ID (0000:04:00.0,0000:04:00.1)\n"
	printf -- "  This script will attempt to bind the device to vfio-pci kernel module.\n"
	printf -- "  You must ensure your system has IOMMU enabled.  Devices must be listed in increments of 2.\n"
	printf -- "\n"
	printf -- "--active-devices=str,str\n"
	printf -- "  List of 2 (ore more) DPDK devices to use as active participants in the test.  These devices\n"
	printf -- "  must be a subset of what is supplied for --devices.  Devices must be listed in increments of 2.\n"
	printf -- "\n"
	printf -- "--one-shot\n"
	printf -- "  Run one test for throughput at specified rate\n"
	printf -- "\n"
	printf -- "--sniff-runtime=int\n"
	printf -- "  Measurement period in seconds for a \"sniff\" trial, right before the search trial\n"
	printf -- "  if the sniff test fails, the search trial is skipped and moves on to the next trial\n"
	printf -- "  Default is $sniff_runtime\n"
	printf -- "\n"
	printf -- "--search-runtime=int\n"
	printf -- "  Measurement period in seconds when searching for max throughput\n"
	printf -- "  Default is $search_runtime\n"
	printf -- "\n"
	printf -- "--validation-runtime=int\n"
	printf -- "  Measurement period in seconds when running final validation or a latency test\n"
	printf -- "  Default is $validation_runtime\n"
	printf -- "\n\n"
	printf -- "      The follwoing options can take 1 or more values and will control how many\n"
	printf -- "      tests will be conducted.  For example, the following options:\n"
	printf -- "\n"
	printf -- "        --rates=1,2 --traffic-directions=unidirec,bidirec --max-loss-pcts=0,1\n"
	printf -- "        --frame-sizes=64,256 --nr-flows=1024,65536\n"
	printf -- "\n"
	printf -- "      would produce 32 different test permutations\n"
	printf -- "\n"
	printf -- "--rate[s]=value[,value]]\n"
	printf -- "  A list of packet rates, in millions of packets per second (mpps), unless\n"
	printf -- "  --rate-unit=%% is used, where the rate value is interpreted as a percentage\n"
	printf -- "  of line rate for the trasmitting device.\n"
	printf -- "\n"
	printf -- "  Only use this option when:\n"
	printf -- "    1) Using the --one-shot option (skip binary search) and only 1 frame size\n"
	printf -- "      For example, you may want to use this when measuring latency for\n"
	printf -- "      10%%, 50%%, 90%% of line rate with 64-byte frames:\n"
	printf -- "      --rates=10%%,50%%,90%% --rate-unit=%% --frame-size=64 --one-shot\n"
	printf -- "    2) Performing a binary search, but you want the search to start with a rate\n"
	printf -- "       lower than 100%%.  Wen doing this, it is recommended that only 1 frame\n"
	printf -- "       size is used:\n"
	printf -- "       --rate=50%% --rate-unit=%% --frame-size=64\n"
	printf -- "\n"
	printf -- "--traffic-direction[s]=str[,str]\n"
	printf -- "  A list of one or more: unidirec, revunidirec, or bidirec (default $traffic_directions)\n"
	printf -- "  unidirec: packets will Tx out the 1st device and Rx in the 2nd device\n"
	printf -- "  revunidirec: packets will Tx out the 2nd device and RX in the 1st device\n"
	printf -- "  biidirec: packets will Tx out the both devices and Rx in both devices\n"
	printf -- "\n"
	printf -- "--max-loss-pct[s]=fl,[fl]\n"
	printf -- "  A list of maximum allowed percentage of dropped frames, used for binary search\n"
	printf -- "  Default is $max_loss_pcts\n"
	printf -- "\n"
	printf -- "--frame-sizes=str[,str]\n"
	printf -- "  A list of Ethernet frame sizes (including CRC) in bytes\n"
	printf -- "  Default is $frame_sizes\n"
	printf -- "\n"
	printf -- "--num-flows=int\n"
	printf -- "  Number of packet flows to run. Default is $num_flows\n"
	printf -- "\n\n"
	#                   1         2         3         4         5         6         7         8
	#          12345678901234567890123456789012345678901234567890123456789012345678901234567890
	printf -- "trafficgen options that control packet contents\n"
	printf -- "-----------------------------------------------\n"
	printf -- "\n"
	printf -- "    The values provided for the following options correspond to the devices\n"
	printf -- "    device list (--devices).  For example\n"
	printf -- "\n"
	printf -- "      --devices=0000:04:00.0,0000:04:00.1 --src-ips=10.0.0.1,8.0.0.1\n"
	printf -- "\n"
	printf -- "    In the example above, device 0000:04:00.0 would use source IP address 10.0.0.1\n"
	printf -- "    and device 0000:04:00.1 would use source IP adress 8.0.0.1\n"
	printf -- "\n"
	printf -- "--src-ports=PORT,PORT\n"
	printf -- "  A list of source ports\n"
	printf -- "\n"
	printf -- "--dst-ports=PORT,PORT\n"
	printf -- "  A list of destination ports\n"
	printf -- "\n"
	printf -- "--src-macs=MAC,MAC\n"
	printf -- "  A list of two source MAC addresses\n"
	printf -- "\n"
	printf -- "--src-ips=IP,IP\n"
	printf -- "  A list of two source IP addresses\n"
	printf -- "\n"
	printf -- "--dst-macs=MAC,MAC\n"
	printf -- "  A list of two destination MAC addresses\n"
	printf -- "\n"
	printf -- "--dst-ips=IP,IP\n"
	printf -- "  A list of two destination IP addresses\n"
	printf -- "\n"
	printf -- "--encap-src-macs=MAC,MAC\n"
	printf -- "  A list of two source MAC addresses for the encapsulated network. Only used in\n"
	printf -- "  conjuction with an overlay network like VxLAN\n"
	printf -- "\n"
	printf -- "--encap-src-ips=IP,IP\n"
	printf -- "  A list of two source IP addresses for the encapsulated network.  Only used in\n"
	printf -- "  conjuction with an overlay network like VxLAN.\n"
	printf -- "\n"
	printf -- "--encap-dst-macs=MAC,MAC\n"
	printf -- "  A list of two destination MAC addresses for the encapsulated network.  Only\n"
	printf -- "  used on conjuction with an overlay network like VxLAN.\n"
	printf -- "\n"
	printf -- "--encap-dst-ips=IP,IP\n"
	printf -- "  A list of two destination IP addresses for the encapsulated network.  Only\n"
	printf -- "  used on conjuction with an overlay network like VxLAN.\n"
	printf -- "\n"
	printf -- "--vlan-ids=[int][,int]\n"
	printf -- "  If a value is provided, the corresponding device will use a VLAN tag when\n"
	printf -- "  transmitting and expect received packets to also have the VLAN tag\n"
	printf -- "\n"
	printf -- "--overlay-ids=[int][,int]\n"
	printf -- "  If a value is provided, the corresponding device will encapsulate the packet\n"
	printf -- "  and use VNI = value provided when transmitting packets.  Received packets\n"
	printf -- "  for the this device are expected to be encapsulated and use same VNI.  This\n"
	printf -- "  option must be used with --overlay-type option\n"
	printf -- "\n"
	#                   1         2         3         4         5         6         7         8
	#          12345678901234567890123456789012345678901234567890123456789012345678901234567890
	printf -- "--overlay-types\n"
	printf -- "  Per device specification of overlay network type, can be \"none\", or skipped,\n"
	printf -- "  or \"VxLAN\".  If \"VxLAN\" is used, --overlay-ids must also be used as well\n"
	printf -- "  as --encap-[src|dst]-[macs|ips] options.  When using an overlay, the\n"
	printf -- "  device-under-test must have the matching configuration.  For example, if\n"
	printf -- "  --overlay-types=none,vxlan is used, the device-under-test would receive\n"
	printf -- "  non-overlay packets on its first device, encapsulate the packets, and send\n"
	printf -- "  the packet out the second device.  Packets received by the second device are\n"
	printf -- "  expected to already be encapsulated, and the device-under-test would\n"
	printf -- "  decapsulate them and send them out the first device.\n"
	printf -- "\n"
	printf -- "--flow-mods=str[,str] (default is $flow_mods)\n"
	printf -- "  A list of IP packet header fields which are used to implement unique flows.\n"
	printf -- "  All fields listed here are changed in unison, for example if \"src-ip,src-mac\"\n"
	printf -- "  are used, the first packet will have a source IP of 192.168.0.X and source MAC\n"
	printf -- "  of 01:02:03:04:X:06.  The second packet will have a source IP of\n"
	printf -- "  192.168.0.(X+1) and source MAC of 01:02:03:04:(X+1):06. The list of available\n"
	printf -- "  flow mods are:\n\n"
	printf -- "    src-ip,dst-ip,src-mac,dst-mac,src-port,dst-port,encap-src-mac,encap-dst-mac,\n"
        printf -- "    encap-src-ip,encap-dst-ip,protocol,none\n\n"
	printf -- "  Note that none is a special flow mod option.  It's presence will override and\n"
	printf -- "  disable all other specified flow mods\n"
	printf -- "  Note that the encap-* flow mods are only viable for overlay network tests like\n"
	printf -- "  VxLAN, and alter the inner packet header.\n"
	printf -- "  The maximum number of unique flows may be limited by the traffic-generator used.\n"
	printf -- "  For trex-txrx, it is 16.7 million.  Trex-txrx modifies the 2nd, 3rd, and 4th\n"
	printf -- "  octet in the IP addresses and the 3rd, 4th, and 5th octet in the MAC addresses\n"
	printf -- "  When using source or destination ports numbers, the range is limited to 1-32768\n"
	printf -- "  and higher flow counts will \"roll\" over back to 1\n"
	printf -- "\n"
	printf -- "--packet-protocol=str (default is $packet_protocol)\n"
	printf -- "  The protocol to use when generating IP packets.  Available options are TCP or\n"
	printf -- "  UDP.\n"
	printf -- "\n"
	printf -- "--trex-use-ht\n"
	printf -- "  Should TRex be allowed to use Hyperthreading siblings.  Defaults to disabled.\n"
	printf -- "--trex-use-l2\n"
	printf -- "  Should TRex be configured in L2 mode instead of L3.  Defaults to disabled.\n"
	printf -- "\n\n"
	printf -- "trafficgen debug options\n"
	printf -- "-----------------------------------------------\n"
	printf -- "\n"
	printf -- "--skip-trex-install\n"
	printf -- "  Do no install TRex server process (assumes you have one) installed already\n"
	printf -- "\n"
	printf -- "--skip-trex-server\n"
	printf -- "  Do no kill existing or start a new TRex server process (assumes you have one)\n"
	printf -- "  running already)\n"
	printf -- "\n"
	printf -- "--skip-git-pull\n"
	printf -- "  Do not call git pull on the lua-trafficgen repo if it already exists\n"
	printf -- "\n\n"
	printf -- "options common in most pbench benchmark scripts\n"
	printf -- "-----------------------------------------------\n"
	printf -- "\n"
	printf -- "--config=str\n"
	printf -- "  Name of the test config (i.e. jumbo_frames_and_network_throughput)\n"
	printf -- "\n"
	printf -- "--samples=int\n"
	printf -- "  The number of times each different test is run (to compute average)\n"
	printf -- "\n"
	printf -- "--max-failures=int\n"
	printf -- "  The maximm number of failures to get below stddev\n"
	printf -- "\n"
	printf -- "--max-stddev=int\n"
	printf -- "  The maximm percent stddev allowed to pass\n"
	printf -- "\n"
	printf -- "--postprocess-only=y|n\n"
	printf -- "  Don't run the benchmark, but postprocess data from previous test\n"
	printf -- "\n"
	printf -- "--run-dir=str\n"
	printf -- "  Optionally specify what directory should be used (usually only used if\n"
	printf -- "  postprocess-only=y)\n"
	printf -- "\n"
	printf -- "--start-iteration-num=int\n"
	printf -- "  Optionally skip the first (n-1) tests\n"
	printf -- "\n"
	printf -- "--tool-group=str\n"
	printf -- "  Start/stop/post-process tools using this group\n"
	exit 1
fi
eval set -- "$opts"
debug_log "[$script_name]processing options"
while true; do
	case "$1" in
		--install)
		shift
		install_only="y"
		exit
		;;
		--tool-label-pattern)
		shift
		if [ -n "$1" ]; then
			tool_label_pattern="$1"
			shift
		fi
		;;
		--postprocess-only)
		shift
		if [ -n "$1" ]; then
			postprocess_only="$1"
			shift
		fi
		;;
		--run-dir)
		shift
		if [ -n "$1" ]; then
			benchmark_run_dir="$1"
			shift
		fi
		;;
		--max-stddev)
		shift
		if [ -n "$1" ]; then
			maxstddevpct="$1"
			shift
		fi
		;;
		--max-failures)
		shift
		if [ -n "$1" ]; then
			max_failures="$1"
			shift
		fi
		;;
		--samples)
		shift
		if [ -n "$1" ]; then
			num_samples="$1"
			shift
		fi
		;;
		--traffic-generator)
		shift
		if [ -n "$1" ]; then
			traffic_generator="$1"
			shift
		fi
		;;
		--num-flows)
		shift
		if [ -n "$1" ]; then
			num_flows="$1"
			shift
		fi
		;;
		--rate-unit)
		shift
		if [ -n "$1" ]; then
			rate_unit="$1"
			shift
		fi
		;;
		--rate|--rates)
		shift
		if [ -n "$1" ]; then
			rates="$1"
			shift
		fi
		;;
		--rate-tolerance-pct)
		shift
		if [ -n "$1" ]; then
			rate_tolerance_pct="$1"
			shift
		fi
		;;
		--max-loss-pct|--max-loss-pcts)
		shift
		if [ -n "$1" ]; then
			max_loss_pcts="$1"
			shift
		fi
		;;
		--traffic-direction|--traffic-directions)
		shift
		if [ -n "$1" ]; then
			traffic_directions="$1"
			shift
		fi
		;;
		--tool-group)
		shift
		if [ -n "$1" ]; then
			tool_group="$1"
			shift
		fi
		;;
		--frame-size|--frame-sizes)
		shift
		if [ -n "$1" ]; then
			frame_sizes="$1"
			shift
		fi
		;;
		--devices)
		shift
		if [ -n "$1" ]; then
			devices="$1"
			shift
		fi
		;;
		--active-devices)
		shift
		if [ -n "${1}" ]; then
			active_devices="${1}"
			shift
		fi
		;;
		--config)
		shift
		if [ -n "$1" ]; then
			config="$1"
			shift
		fi
		;;
		--start-iteration-num)
		shift
		if [ -n "$1" ]; then
			start_iteration_num=$1
			shift
		fi
		;;
		--one-shot)
		shift
		one_shot="y"
		;;
		--trex-use-ht)
		shift
		trex_use_ht="y"
		;;
		--trex-use-l2)
		shift
		trex_use_l2="y"
		;;
		--flow-mods)
		shift
		if [ -n "$1" ]; then
		    flow_mods="$1"
		    shift
		fi
		;;
		--validation-runtime|--sniff-runtime|--search-runtime)
		arg="$1"
		shift
		if [ -n "$1" ]; then
			val=$1
			var=`echo $arg | sed -e s/^--// -e s/-/_/g`
			eval $var=$val
		shift
		fi
		;;
		# for options which if not used, do not affect the binary-search.py options (and binary-search should not use them by default)
		# these options must match the options to binary-search.py *exactly*
		--overlay-ids|--vlan-ids|--overlay-types|--src-ips|--src-macs|--dst-ips|--dst-macs|--encap-src-ips|--encap-src-macs|--encap-dst-ips|--encap-dst-macs|--src-ports|--dst-ports|--packet-protocol)
		arg="$1"
		shift
		if [ -n "$1" ]; then
			val=$1
			cmd="$cmd $arg=$val"
			var=`echo $arg | sed -e s/^--// -e s/-/_/g`
			eval $var=$val
		shift
		fi
		;;
		--skip-trex-install)
		shift
		skip_trex_install="y"
		;;
		--skip-trex-server)
		shift
		skip_trex_server="y"
		;;
		--skip-git-pull)
		shift
		skip_git_pull="y"
		;;
		--)
		shift
		while true; do
			arg="$1"
			shift
			if [ -n "$arg" ]; then
				cmd="$cmd $arg"
			else
				break
			fi
		done
		break
		;;
		*)
		error_log "[$script_name] bad option, \"$1 $2\""
		exit 1
		break
		;;
	esac
done

if [ -z "${active_devices}" ]; then
	active_devices=${devices}
fi

# add test options to $config, so this test result directory is easily identifiable
config="${config}_tg[`echo $traffic_generator | sed -e 's/-txrx//'`]r[$rates]fs[$frame_sizes]nf[$num_flows]fm[`echo $flow_mods | sed -e 's/src-/s/g' -e 's/dst-/d/g' -e 's/ip/i/g' -e 's/mac/m/g' -e 's/port/p/g'`]td[`echo $traffic_directions | sed -e 's/direc//g'`]ml[$max_loss_pcts]"
if [ "$one_shot" == "y" ]; then
	config="${config}tt[os]"
else
	config="${config}tt[bs]"
fi

if [ "$traffic_generator" == "trex-txrx" -o "$traffic_generator" == "moongen-txrx" ]; then
	cmd="$cmd --traffic-generator=$traffic_generator --rate-tolerance=$rate_tolerance_pct"
else
	warn_log "The traffic engine is not valid: $traffic_generator"
	exit 1
fi

for num_flow in `echo $num_flows | sed -e 's/,/ /g'`; do
	if ! [ $num_flow -gt 0 -a $num_flow -le 16777216 ]; then
		log_warn "This number of flows is invalid: $num_flow"
		exit 1
	fi
done

not_flow_mods="$all_possible_flow_mods"
if ! echo "$flow_mods" | grep -e "^none$" -e ",none$" -e "^none," -e ",none,"; then
	for flow_mod in `echo $flow_mods | sed -e 's/,/ /g'`; do
		found_flow_mod=0
		for this_flow_mod in `echo $all_possible_flow_mods | sed -e 's/,/ /g'`; do
			if [ $flow_mod = $this_flow_mod ]; then
				cmd="$cmd --use-${flow_mod}-flows=1"
				found_flow_mod=1
				not_flow_mods=`echo $not_flow_mods | sed -e s/^$flow_mod,// -e s/,$flow_mod,/,/ -e s/,$flow_mod//`
			fi
		done
		if [ $found_flow_mod -eq 0 ]; then
			warn_log "This flow_mod is invalid: $flow_mod"
			exit 1
		fi
	done
fi
# ensure the other flows are forced off (avoiding any defaults from binary-search.py)
for flow_mod in `echo $not_flow_mods | sed -e 's/,/ /g'`; do
	if [ "${flow_mod}" == "none" ]; then
		continue
	else
		cmd="$cmd --use-${flow_mod}-flows=0"
	fi
done

if [ $one_shot == "y" ]; then
	cmd="$cmd --one-shot=1"
fi

# Before running any tests, the following must be satisfied:
# -IOMMU must be enabled
if cat /proc/cmdline | grep -q "intel_iommu=on"; then
	echo "found IOMMU option, continuing"
else
	warn_log "could not find IOMMU option, intel_iommu=on, in /proc/cmdline, exiting"
	exit 1
fi
# -dpdk-tools package must be installed
if check_install_rpm dpdk-tools; then
	echo "found dpdk-tools, continuing"
else
	warn_log "could not find dpdk-tools, exiting"
	exit 1
fi
# -PCI devices bound to vfio-pci
if [ -z "$devices" ]; then
	warn_log "no devices were provided (--devices), exiting"
	exit 1
fi
for module in vfio vfio_pci; do
	if [ ! -e /sys/module/$module ]; then
		echo "attempting to load $module"
		modprobe $module
		if [ ! -e /sys/module/$module ]; then
			error_log "could not load $module module, exiting"
			exit 1
		fi
	fi
done
total_devices=$(echo ${devices} | sed -e "s/,/ /g" | wc -w)
if [ $(echo "${total_devices} % 2" | bc) != 0 ]; then
	error_log "devices must be supplied in quantities of 2, exiting"
	exit 1
else
	total_device_pairs=$(echo "${total_devices} / 2" | bc)
	if [ $traffic_generator == "trex-txrx" ]; then
		device_pair_index=0
		cmd+=" --device-pairs="
		for device in $(seq 1 2 ${total_devices}); do
			device_a=$(( device - 1))
			device_b=${device}
			cmd+="${device_a}:${device_b}"
			(( device_pair_index++ ))
			if [ ${device_pair_index} -lt ${total_device_pairs} ]; then
				cmd+=","
			fi
		done
	else
		if [ "${total_device_pairs}" -gt 1 ]; then
			error_log "only the trex-txrx traffic generator supports more than 1 pair of devices, exiting"
			exit 1
		fi
	fi
fi
total_active_devices=$(echo ${active_devices} | sed -e "s/,/ /g" | wc -w)
if [ $(echo "${total_active_devices} % 2" | bc) -ne 0 ]; then
	error_log "active devices must be supplied in quantities of 2, exiting"
	exit 1
else
	if [ $traffic_generator != "trex-txrx" -a "${devices}" != "${active_devices}" ]; then
		error_log "only the trex-txrx traffic generator supports --devices != --active-devices, exiting"
		exit 1
	else
		if [ $traffic_generator == "trex-txrx" ]; then
			active_device_pair_index=0
			cmd+=" --active-device-pairs="
			active_device_state=0
			active_devices_processed=0
			for active_device in `echo $active_devices | sed -e s/,/" "/g`; do
				device_index=0
				active_device_index=-1
				for device in `echo $devices | sed -e s/,/" "/g`; do
					if [ "${device}" == "${active_device}" ]; then
						active_device_index=${device_index}
					fi
					(( device_index++ ))
				done
				(( active_devices_processed++ ))
				if [ ${active_device_index} -ne -1 ]; then
					if [ ${active_device_state} -eq 0 ]; then
						cmd+="${active_device_index}:"
						(( active_device_state++ ))
					elif [ ${active_device_state} -eq 1 ]; then
						cmd+="${active_device_index}"
						active_device_state=0
						if [ ${active_devices_processed} -lt ${total_active_devices} ]; then
							cmd+=","
						fi
					fi
				else
					error_log "couldn't find an active device [${active_device}] in the list of devices [${devices}], exiting"
					exit 1
				fi
			done
		fi
	fi
fi
for dev in `echo $devices | sed -e s/,/" "/g`; do
	echo "configuring device $dev"
	if /bin/ls /sys/module/vfio_pci/drivers/pci\:vfio-pci/ | grep -q "$dev"; then
		echo "device $dev already bound to vfio-pci"
	else
		if [ -e /sys/bus/pci/devices/$dev/driver ]; then
			if dpdk-devbind -u $dev; then
				dpdk-devbind -b vfio-pci $dev
			else
				log_warn "could not unbind device, exiting"
				exit 1
			fi
		else
			dpdk-devbind -b vfio-pci $dev
		fi
	fi
done
for dev in `echo $devices | sed -e s/,/" "/g`; do
	if /bin/ls /sys/module/vfio_pci/drivers/pci\:vfio-pci/ | grep -q "$dev"; then
		echo "device $dev bound to vfio-pci"
	else
		echo "device $dev not bound to vfio-pci, exiting"
	fi
done

if [ -d $trafficgen_dir ]; then
	if [ $skip_git_pull == "n" ]; then
		if pushd $trafficgen_dir >/dev/null && git pull && git checkout master; then
			echo "lua-trafficgen is up to date"
			popd >/dev/null
		else
			warn_log "could not get latest lua-trafficgen"
			exit 1
		fi
	fi
else
	if pushd /opt >/dev/null && git clone https://github.com/atheurer/lua-trafficgen.git; then
		echo "lua-trafficgen is up to date"
		popd >/dev/null
	else
		warn_log "could not get latest lua-trafficgen"
		exit 1
	fi
fi

# Moongen is built under the lua-trafficgen repo
if [ $traffic_generator == "moongen-txrx" ]; then
	if ! [ -x $trafficgen_dir/MoonGen/build/MoonGen ]; then
		pushd >/dev/null $trafficgen_dir
		echo "building MoonGen"
		if ./setup.sh; then
			echo "MoonGen build complete"
		else
			warn_log "could not build MoonGen"
			exit 1
		fi
	fi
fi
	
if [ $traffic_generator == "trex-txrx" -a $skip_trex_server == "n" ]; then
	kill_trex

	trex_base_dir="/opt/trex"
	trex_dir="${trex_base_dir}/current"
	if [ "${skip_trex_install}" == "n" ]; then
		if ! ${trafficgen_dir}/install-trex.sh --tmp-dir=${pbench_tmp} --base-dir=${trex_base_dir}; then
			exit 1
		fi
	fi

	if ! ${trafficgen_dir}/launch-trex.sh --tmp-dir=${pbench_tmp} --trex-dir=${trex_dir} --use-ht=${trex_use_ht} --use-l2=${trex_use_l2} --devices=${devices}; then
		exit 1
	fi

	popd >/dev/null
fi

if [[ -z "$benchmark_run_dir" ]]; then
	# We don't have an explicit run directory, construct one
	benchmark_fullname="${benchmark_name}_${config}_${date}"
	benchmark_run_dir="$pbench_run/${benchmark_fullname}"
else
	# We have an explicit run directory provided by --run-dir, so warn
	# the user if they also used --config
	if [[ ! -z "$config" ]]; then
		warn_log "[$script_name] ignoring --config=\"$config\" in favor of --rundir=\"$benchmark_run_dir\""
	fi
	benchmark_fullname=$(basename $benchmark_run_dir)
fi
benchmark_iterations="$pbench_tmp/${benchmark_fullname}.iterations"
mkdir -p $benchmark_run_dir/.running
# save a copy of the command, in case the test needs to be reproduced or post-processed again
echo "$script_name $pbench_cmd" >$benchmark_run_dir/$script_name.cmd
chmod +x $benchmark_run_dir/$script_name.cmd

total_iterations=0
for traffic_direction in `echo $traffic_directions | sed -e s/,/" "/g`; do
	for max_loss_pct in `echo $max_loss_pcts | sed -e s/,/" "/g`; do
		for frame_size in `echo $frame_sizes | sed -e s/,/" "/g`; do
			for num_flow in `echo $num_flows | sed -e s/,/" "/g`; do
				((total_iterations++))
			done
		done
	done
done
echo "Total number of benchmark iterations: $total_iterations"
count=1
mkdir -p $benchmark_run_dir/.running
export benchmark_name config
#pbench-collect-sysinfo --group=$tool_group --dir=$benchmark_run_dir beg

rc=0
for rate in `echo $rates | sed -e s/,/" "/g`; do
	if [ $rc -ne 0 ]; then
		break
	fi
	for traffic_direction in `echo $traffic_directions | sed -e s/,/" "/g`; do
		if [ $rc -ne 0 ]; then
			break
		fi
		for max_loss_pct in `echo $max_loss_pcts | sed -e s/,/" "/g`; do
			if [ $rc -ne 0 ]; then
				break
			fi
			# if any of the runtimes are provided by the user, then use those
			unset iteration_sniff_runtime
			unset iteration_search_runtime
			unset iteration_validation_runtime
			if [ ! -z "$sniff_runtime" ]; then
				iteration_sniff_runtime=$sniff_runtime
			fi
			if [ ! -z "$search_runtime" ]; then
				iteration_search_runtime=$search_runtime
			fi
			if [ ! -z "$validation_runtime" ]; then
				iteration_validation_runtime=$validation_runtime
			fi
			# for any runtimes not provided by user, assign a default value
			# there are different defaults for 0-loss and non-zero-loss
			if [ -z "$iteration_sniff_runtime" ]; then
				if [[ $(echo "if (${max_loss_pct} == 0) 1 else 0" | bc) -eq 1 ]]; then
					iteration_sniff_runtime=$df_zl_sniff_runtime
				else
					iteration_sniff_runtime=$df_sniff_runtime
				fi
			fi
			if [ -z "$iteration_search_runtime" ]; then
				if [[ $(echo "if (${max_loss_pct} == 0) 1 else 0" | bc) -eq 1 ]]; then
					iteration_search_runtime=$df_zl_search_runtime
				else
					iteration_search_runtime=$df_search_runtime
				fi
			fi
			if [ -z "$iteration_validation_runtime" ]; then
				if [[ $(echo "if (${max_loss_pct} == 0) 1 else 0" | bc) -eq 1 ]]; then
					iteration_validation_runtime=$df_zl_validation_runtime
				else
					iteration_validation_runtime=$df_validation_runtime
				fi
			fi
			cmd="$cmd --sniff-runtime=$iteration_sniff_runtime"
			cmd="$cmd --search-runtime=$iteration_search_runtime"
			cmd="$cmd --validation-runtime=$iteration_validation_runtime"
			for frame_size in `echo $frame_sizes | sed -e s/,/" "/g`; do
				if [ $rc -ne 0 ]; then
					break
				fi
				for num_flow in `echo $num_flows | sed -e s/,/" "/g`; do
					if [ $rc -ne 0 ]; then
						break
					fi
					if [ $count -ge $start_iteration_num ]; then
						iteration_options=""
						if [ $rate == "none" ]; then
							if [ $traffic_generator == "trex-txrx" ]; then
								iteration_options="$iteration_options --rate-unit=% --rate=100"
							else
								# don't specify a rate and let binary-search.py + whatever traffic-generator figure it out
								iteration_options="$iteration_options"
							fi
						else
							iteration_options="$iteration_options --rate-unit=$rate_unit --rate=$rate"
						fi
						fs_unit=""
						if [ "${frame_size}" -eq "${frame_size}" ] 2>/dev/null; then
							fs_unit="B"
						fi
						iteration="${count}-${traffic_direction}-${frame_size}${fs_unit}-${num_flow}flows-${max_loss_pct}pct_drop"
                                                echo $iteration >> $benchmark_iterations
						iteration_dir="$benchmark_run_dir/$iteration"
						mkdir -p $iteration_dir
						benchmark_cmd_file="$iteration_dir/$benchmark_name.cmd"
						result_stddevpct=$maxstddevpct # this test case will get a "do-over" if the stddev is not low enough
						failures=0
						echo "Starting iteration[$iteration] ($count of $total_iterations)"
						log "Starting iteration[$iteration] ($count of $total_iterations)"
						# Add any benchmark-iteration-specific options
						if [  $traffic_direction == "unidirec" ]; then
							iteration_options="$iteration_options --run-bidirec=0 --run-revunidirec=0"
						elif [ $traffic_direction == "revunidirec" ]; then
							iteration_options="$iteration_options --run-bidirec=0 --run-revunidirec=1"
						else
							iteration_options="$iteration_options --run-bidirec=1 --run-revunidirec=0"
						fi
						iteration_options="$iteration_options --max-loss-pct=$max_loss_pct"
						iteration_options="$iteration_options --frame-size=$frame_size"
						iteration_options="$iteration_options --num-flows=$num_flow"
						# save benchmark command in file for debugging or running manually
						echo "pushd >/dev/null $trafficgen_dir" >$benchmark_cmd_file
						echo "$cmd $iteration_options \$@" >>$benchmark_cmd_file
						echo "cmd_rc=\$?" >>$benchmark_cmd_file
						echo "popd >/dev/null" >>$benchmark_cmd_file
						echo "exit \$cmd_rc" >>$benchmark_cmd_file
						chmod +x $benchmark_cmd_file
						while [[ $(echo "if (${result_stddevpct} >= ${maxstddevpct}) 1 else 0" | bc) -eq 1 ]]; do
							if [[ $failures -gt 0 ]]; then
								echo "Restarting iteration[$iteration] ($count of $total_iterations)"
								log "Restarting iteration[$iteration] ($count of $total_iterations)"
							fi
							# each attempt at a test config requires multiple samples to get stddev
							for sample in `seq 1 $num_samples`; do
								if [ $rc -ne 0 ]; then
									break
								fi
								benchmark_results_dir="$iteration_dir/sample$sample"
								if [ "$postprocess_only" != "y" ]; then
									mkdir -p $benchmark_results_dir
									echo "test sample $sample of $num_samples"
									log "test sample $sample of $num_samples "
									result_file=$benchmark_results_dir/result.txt
									pbench-start-tools --group=$tool_group --iteration=$iteration --dir=$benchmark_results_dir
									$benchmark_cmd_file --output-dir=$benchmark_results_dir 2>&1 | tee -i $result_file
									rc=$?
									pbench-stop-tools --group=$tool_group --iteration=$iteration --dir=$benchmark_results_dir
									pbench-postprocess-tools --group=$tool_group --iteration=$iteration --dir=$benchmark_results_dir
									echo "exit code: $rc"
									if [ $rc -ne 0 ]; then
										error_log "iteration $iteration sample $sample returned non-zero exit code"
									fi
								else
									if [[ ! -d $benchmark_results_dir ]]; then
										error_log "Results directory $benchmark_results_dir does not exist, skipping post-processing"
										continue
									fi
									echo "Not going to run $benchmark_name.  Only postprocesing existing data"
									log "Not going to run $benchmnark_name.  Only postprocesing existing data"
								fi
								if [ $rc -eq 0 ]; then
									echo "$script_path/postprocess/$benchmark_name-postprocess $benchmark_results_dir $iteration $max_loss_pct $tool_label_pattern $tool_group" >"$benchmark_results_dir/$benchmark_name-postprocess.cmd"
									chmod +x "$benchmark_results_dir/$benchmark_name-postprocess.cmd"
									$benchmark_results_dir/$benchmark_name-postprocess.cmd || rc=1
								fi
							done
							if [ $rc -eq 0 ]; then
								echo "$script_path/postprocess/process-iteration-samples $iteration_dir Mframes_sec $maxstddevpct $failures $max_failures $tar_nonref_data $keep_failed_tool_data" >"$iteration_dir/process-iteration-samples.cmd"
								chmod +x "$iteration_dir/process-iteration-samples.cmd"
								$iteration_dir/process-iteration-samples.cmd
								fail=$?
								if [ $fail -eq 1 ]; then
									error_log "This test iteration failed"
									((failures++))
								fi
								if [ $fail -eq 0 -o $failures -ge $max_failures ]; then
									debug_log "Moving to the next iteration"
									break
								fi
							else
								error_log "Aborting benchmark"
								break
							fi
						done # break out of this loop only if the $result_stddevpct is lower than $maxstddevpct
						if [ $rc -eq 0 ]; then
							echo "Iteration $iteration complete ($count of $total_iterations), with 1 pass and $failures failures"
							log "Iteration $iteration complete ($count of $total_iterations), with 1 pass and $failures failures"
						fi
					else
						echo "Skipping iteration $iteration ($count of $total_iterations)"
						log "Skipping iteration $iteration ($count of $total_iterations)"
					fi
					let count=$count+1 # now we can move to the next iteration
				done
			done
		done
	done
done
if [ $rc -eq 0 ]; then
	echo "$script_path/postprocess/generate-benchmark-summary $benchmark_name $orig_cmd $benchmark_run_dir" >"$benchmark_run_dir/generate-benchmark-summary.cmd"
	$script_path/postprocess/generate-benchmark-summary "$benchmark_name" "$orig_cmd" "$benchmark_run_dir"
	#pbench-collect-sysinfo --group=$tool_group --dir=$benchmark_run_dir end
fi
if [ $traffic_generator == "trex-txrx" -a $skip_trex_server == "n" ]; then
	kill_trex

	if [ "${trex_use_l2}" == "y" ]; then
		mv -v /etc/trex_cfg.yaml.pbench-backup /etc/trex_cfg.yaml
	fi
fi
rmdir $benchmark_run_dir/.running
