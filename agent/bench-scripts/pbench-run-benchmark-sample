#!/usr/bin/perl
#
# Author: Andrew Theurer
#
# This script:
# - executes a single sample of a benchmark 
# - runs any postprocessing to get all data in JSON
#
# There are 2 ways to run a benchmark:
# 1) using built-in functions in this script
# 2) using external script specifically for that benchmark
#
# Benchmarks executions handled by this script
# benefit from sharing other functions, like methods
# to copy files to/from client/servers

use strict;
use warnings;
use File::Basename;
my $pbench_lib_path;
my $script_path;
my $script_name;
BEGIN {
	$script_path = dirname($0);
	$script_name = basename($0);
	$pbench_lib_path = $script_path . "/postprocess";
}
use lib "$pbench_lib_path";
use JSON;
use File::Temp;
use Data::Dumper;
use PbenchBase qw(get_json_file put_json_file get_benchmark_names get_clients get_params);
use PbenchAnsible qw(ssh_hosts ping_hosts copy_files_to_hosts copy_files_from_hosts remove_files_from_hosts remove_dir_from_hosts create_dir_hosts sync_dir_from_hosts verify_success);
use PbenchCDM qw (create_bench_iter_sample_doc);
my $pbench_bench_config_dir = $script_path;
$pbench_bench_config_dir =~ s/bench-scripts$/config\/benchmark\//;

# load a benchmark json file which tells us how to run a benchmark
sub load_benchmark_specs {
	my $benchmark_name = shift;
	my $benchmark_spec_file = $pbench_bench_config_dir . $benchmark_name . ".json";
	my $json_ref = get_json_file($benchmark_spec_file);
	return %$json_ref
}



# main program starts here

# the only required argument is the benchmark name; verify it now
if (scalar @ARGV < 4) {
	print "You must supply at least a benchmark name, results directory, and the base benchmark directory:\n";
	printf "%s\n", join(" ", get_benchmark_names($pbench_bench_config_dir));
	exit;
}
my $run_id = shift(@ARGV);
printf "run_id[$run_id]\n";
my $benchmark = shift(@ARGV);
if (!grep(/^$benchmark$/, get_benchmark_names($pbench_bench_config_dir))) {
	die "$benchmark is not a valid benchmark";
}
my $rundir = shift(@ARGV);
my $base_bench_dir = shift(@ARGV);
if (! -d $base_bench_dir) {
	die "The base bench  directory must already exist";
}
mkdir($rundir);
my %params = get_params(@ARGV);
my %bench_iter_sample_doc = create_bench_iter_sample_doc;
$bench_iter_sample_doc{"run_id"} = $run_id;
$bench_iter_sample_doc{"benchmark_name"} = $benchmark;
$bench_iter_sample_doc{"benchmark_params"} = join(" ", @ARGV);;
$bench_iter_sample_doc{"benchmark_hosts_clients"} = $params{"clients"};
$bench_iter_sample_doc{"benchmark_hosts_servers"} = $params{"servers"};
my %bench_specs = load_benchmark_specs($benchmark);
my @clients = get_clients(@ARGV);
my %remote_hosts = ( "clients" => \@clients );
# pre-benchmark-execution
# - verify access to clients and servers
# - verify required software on clients and server
# - create rundir on clients and servers
# - copy files to clients and servers
for my $host_type (keys %remote_hosts) {
	if (scalar @{ $remote_hosts{$host_type} }) {
		if ($bench_specs{$host_type} and $bench_specs{$host_type}{"files"} and ${bench_specs}{$host_type}{"files"}{"copy-to"}) {
			my $result;
			my $rc;
			my @files = @{ ${bench_specs}{$host_type}{"files"}{"copy-to"} };
			$result = create_dir_hosts(\@{ $remote_hosts{$host_type} }, $rundir . "-" . $host_type, $base_bench_dir);
			$result = copy_files_to_hosts(\@{ $remote_hosts{$host_type} }, \@files, $rundir . "-" . $host_type, $base_bench_dir);
		}
	}
}
# - execute pre-benchmark scripts on clients and servers
		
# benchmark-execution
# - execute servers then clients, both with their cmdline regex'd if required
my $cmdline = $benchmark . " " . join(" ", @ARGV);
for my $host_type ("servers", "clients") { # the servers then clients order is important here because we want servers to be set up before clients run
	if ($remote_hosts{$host_type} and scalar @{ $remote_hosts{$host_type} }) {
		if ($bench_specs{$host_type} and $bench_specs{$host_type}{"cmdline"} and ${bench_specs}{$host_type}{"cmdline"}{"regex"}) {
			my $new_cmdline = $cmdline;
			for my $transform (@{ $bench_specs{$host_type}{"cmdline"}{"regex"} }) {
				# in order to apply the 's/x/y/' regex from the file, some eval trickery is necessary
				# todo: first test the $transform regex separately for [perl syntax] errors with eval before doing below
				$new_cmdline = eval "\$_='$new_cmdline'; $transform; return scalar \$_";
			}
			my $result = ssh_hosts(\@{ $remote_hosts{$host_type} }, $new_cmdline, $rundir . "-" . $host_type, $base_bench_dir);
		}
	}
}
# post-benhcmark-execution
# - copy files back to controller
for my $host_type ("servers", "clients") {
	if ($remote_hosts{$host_type} and scalar @{ $remote_hosts{$host_type} }) {
		mkdir($rundir . "/clients");
		my $sync_result = sync_dir_from_hosts(\@{ $remote_hosts{$host_type} }, $rundir . "-" . $host_type . "/", $rundir . "/clients", $base_bench_dir); # adding the "/" ensures the base dir name is not copied
		my $remove_result = remove_dir_from_hosts(\@{ $remote_hosts{$host_type} }, $rundir . "-" . $host_type, $base_bench_dir);
	}
}
# - post-process the result data
if ($bench_specs{"postprocess"} and $bench_specs{"postprocess"}{"command"}) {
	put_json_file(\%bench_iter_sample_doc, $rundir . "/bench-iter-sample.json"); # post-processing to finish this document
	my $postprocess_cmd = ". /opt/pbench-agent/base; cd " . $rundir . "; " . $bench_specs{"postprocess"}{"command"} . " " . join(" ", @ARGV); # all options get passed to postprocess in case they are needed
	my $postprocess_output = `$postprocess_cmd`;
	open(my $fh, ">" . $rundir . "/postprocess-output.txt");
	print $fh "$postprocess_output";
} else {
	# If there is no post-processor for the benchmark (there really should be!) then this script will write the bench_iter_saple CDM doc (although not really complete)
	put_json_file(\%bench_iter_sample_doc, $base_bench_dir . "/es/bench/bench-iter-sample-" . $bench_iter_sample_doc{"doc_id"} . ".json");
}

