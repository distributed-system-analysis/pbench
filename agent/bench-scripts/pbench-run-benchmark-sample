#!/usr/bin/perl
#
# Author: Andrew Theurer
#
# This script:
# - executes a single sample of a benchmark 
# - runs any postprocessing to get all data in JSON
#
# Benchmarks executions handled by this script
# benefit from sharing other functions, like methods
# to copy files to/from client/servers

use strict;
use warnings;
use File::Basename;
my $pbench_lib_path;
BEGIN {
	$pbench_lib_path = `getconf.py pbench_install_dir pbench-agent`;
	chomp $pbench_lib_path;
	$pbench_lib_path .= "/lib";
}
use lib "$pbench_lib_path";
use JSON;
use File::Temp;
use Data::Dumper;
use PbenchBase qw(get_json_file put_json_file get_benchmark_names get_clients get_params get_pbench_bench_config_dir);
use PbenchAnsible qw(ssh_hosts ping_hosts copy_files_to_hosts copy_files_from_hosts remove_files_from_hosts remove_dir_from_hosts create_dir_hosts sync_dir_from_hosts verify_success);
use PbenchCDM qw(create_bench_iter_sample_doc);
my $pbench_bench_config_dir = get_pbench_bench_config_dir; 

# load a benchmark json file which tells us how to run a benchmark
sub load_benchmark_specs {
	my $benchmark_name = shift;
	my $benchmark_spec_file = $pbench_bench_config_dir . "/" . $benchmark_name . ".json";
	my $json_ref = get_json_file($benchmark_spec_file);
	return %$json_ref
}


# main program starts here

if (scalar @ARGV < 3) {
	print "You must supply at least the /path/to/iteration-doc.json, results directory, and the base benchmark directory (in that order):\n";
	exit;
}
my $iter_doc_filename = shift(@ARGV);
my $rundir = shift(@ARGV);
my $base_bench_dir = shift(@ARGV);
if (! -d $base_bench_dir) {
	die "The base bench directory $base_bench_dir must already exist";
}
mkdir($rundir);
my $json_ref = get_json_file($iter_doc_filename);
my %bench_iter = %$json_ref; # this is the CDM doc for this benchmark-iteration
#my %params = get_params(split(/,/, $bench_iter{'iter_params'}));
#print "params:\n";
#print Dumper \%params;
my %bench_iter_sample_doc = create_bench_iter_sample_doc(\%bench_iter);;
my %bench_specs = load_benchmark_specs($bench_iter{'run_bench_name'});
my @clients = split(/,/, $bench_iter{'run_bench_clients'});
if (scalar @clients < 1) {
	die "Could not find any hosts assigned to \"run_bench_clients\" in $iter_doc_filename";
}
#my @servers = split(/,/, $bench_iter{'bench_hosts_servers'});
my %remote_hosts = ( "clients" => \@clients );
# pre-benchmark-execution
# - verify access to clients and servers
# - verify required software on clients and server
# - create rundir on clients and servers
# - copy files to clients and servers
for my $host_type (keys %remote_hosts) {
	if (scalar @{ $remote_hosts{$host_type} }) {
		if ($bench_specs{$host_type} and $bench_specs{$host_type}{"files"} and ${bench_specs}{$host_type}{"files"}{"copy-to"}) {
			my $result;
			my $rc;
			my @files = @{ ${bench_specs}{$host_type}{"files"}{"copy-to"} };
			# the end of the dir name gets "-client" or "-server" just in case this host is also a controller or both client and server
			$result = create_dir_hosts(\@{ $remote_hosts{$host_type} }, $rundir . "-" . $host_type, $base_bench_dir);
			$result = copy_files_to_hosts(\@{ $remote_hosts{$host_type} }, \@files, $rundir . "-" . $host_type, $base_bench_dir);
		}
	}
}
# - execute pre-benchmark scripts on clients and servers
#
# start the tools
system("pbench-start-tools --iteration=0 --group=default --dir=" . $rundir);
		
# benchmark-execution
# - execute servers then clients, both with their cmdline regex'd if required
my $cmdline = $bench_iter{'run_bench_name'} . " " . $bench_iter{'iter_params'};
for my $host_type ("servers", "clients") { # the servers then clients order is important here because we want servers to be set up before clients run
	if ($remote_hosts{$host_type} and scalar @{ $remote_hosts{$host_type} }) {
		if ($bench_specs{$host_type} and $bench_specs{$host_type}{"cmdline"} and ${bench_specs}{$host_type}{"cmdline"}{"regex"}) {
			my $new_cmdline = $cmdline;
			for my $transform (@{ $bench_specs{$host_type}{"cmdline"}{"regex"} }) {
				# in order to apply the 's/x/y/' regex from the file, some eval trickery is necessary
				# todo: first test the $transform regex separately for [perl syntax] errors with eval before doing below
				$new_cmdline = eval "\$_='$new_cmdline'; $transform; return scalar \$_";
			}
			printf "new_cmdline[%s]\n", $new_cmdline;
			my $result = ssh_hosts(\@{ $remote_hosts{$host_type} }, $new_cmdline, $rundir . "-" . $host_type, $base_bench_dir);
		}
	}
}

# stop & post-process the tools
system("pbench-stop-tools --iteration=0 --group=default --dir=" . $rundir);

# post-process the tools
system("pbench-postprocess-tools --iteration=0 --group=default --dir=" . $rundir);

# post-benhcmark-execution
# - copy files back to controller
for my $host_type ("servers", "clients") {
	if ($remote_hosts{$host_type} and scalar @{ $remote_hosts{$host_type} }) {
		mkdir($rundir . "/clients");
		my $sync_result = sync_dir_from_hosts(\@{ $remote_hosts{$host_type} }, $rundir . "-" . $host_type . "/", $rundir . "/clients", $base_bench_dir); # adding the "/" ensures the base dir name is not copied
		my $remove_result = remove_dir_from_hosts(\@{ $remote_hosts{$host_type} }, $rundir . "-" . $host_type, $base_bench_dir);
	}
}
# - post-process the result data
if ($bench_specs{"postprocess"} and $bench_specs{"postprocess"}{"command"}) {
	put_json_file(\%bench_iter_sample_doc, $rundir . "/iteration_sample" . ".json"); # post-processing to finish this document
	my $postprocess_cmd = ". /opt/pbench-agent/base; cd " . $rundir . "; " . $bench_specs{"postprocess"}{"command"} . " " . $rundir . " " . $base_bench_dir . " " . join(" ", @ARGV); # all options get passed to postprocess in case they are needed
	my $postprocess_output = `$postprocess_cmd`;
	open(my $fh, ">" . $rundir . "/postprocess-output.txt");
	#print $fh "$postprocess_output";
} else {
	# If there is no post-processor for the benchmark (there really should be!) then this script will write the bench_iter_saple CDM doc (although not really complete)
	put_json_file(\%bench_iter_sample_doc, $base_bench_dir . "/es/bench/iteration-sample-" . $bench_iter_sample_doc{"doc_id"} . ".json");
}
