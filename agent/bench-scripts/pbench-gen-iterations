#!/usr/bin/perl
#
# Author: Andrew Theurer
#
# This script converts a user's list of
# benchmark parameters, validates those parameters,
# and then produces a list of benchmark iterations.
#
# usage:
#
#   pbench-gen-iterations $benchmark_name                         <--required exactly once
#                         --defaults=$defaults_name                <--optional, 1 or more
#                         --$arg=$valueA[,valueB,...valueN] <--optional, 1 or more
#
#   $benchmark_name can be any file found where $benchmark_name is used in
#   $config/${benchmark_name}-parameter-specs.json
#
#   Or a user can get the supported benchmark by runing:
#
#   #pbench-gen-iterations list
#   	fio
#   	uperf
#
#   $defaults_name can be:
#   	any field-name contained in $config/${benchmark}-parameter-defaults.json, for example,
#   	for fio--parameter-defaults.json:
#   	{
#   	"default" : "--rw=read,randr --bs=4k,64k --ioengine=sync --numjobs=1, --filename=/tmp/fio-tst",
#   	"ceph-osp" : "--rw=read,randr,write,randw --bs=1m --ioengine=sync --numjobs=1"
#   	}
#
#   Or a user can ge a list of defaults by running:
#
#   #pbench-gen-iterations fio --defaults=list
#	ceph-osp            |  --rw=read,randr,write,randw --bs=1m --ioengine=sync --numjobs=1
#	default             |  --rw=read,randr --bs=4k,64k --ioengine=sync --numjobs=1, --filename=/tmp/fio-tst
#
#   $parameter is either a pbench universal parameter (like --samples) or a
#   benchmark-native parameter (like --ioengine=sync for fio).  The list of valid 
#   parameters can be found in $config/pbench-parameter-specs.json for universal perameters and
#   $config/${benchmark}-parameter-specs.json for benchmark-native parameters.
#                         
#   Note that a parameter may have mulitple values, and this script will generate a benchmark
#   iteration for each value.  For example, if the user runs:
#
#   #pbench-gen-iterations fio --rw=read,write --bs=4k,1M
#
#   pbench-gen-iterations will generate 4 different iterations:
#
#	pbench_fio --ioengine=sync --filename=/tmp/fio-tst --numjobs=1 --bs=4K --rw=read
#	pbench_fio --ioengine=sync --filename=/tmp/fio-tst --numjobs=1 --bs=4K --rw=write
#	pbench_fio --ioengine=sync --filename=/tmp/fio-tst --numjobs=1 --bs=1024K --rw=read
#	pbench_fio --ioengine=sync --filename=/tmp/fio-tst --numjobs=1 --bs=1024K --rw=write
#
#   Where did the --ioengine=sync --filename=/tmp/fio-tst come from?  The defaults
#   defined for fio ("default" in $config/fio-parameter-defaults.json):
#
#	{
#	"default" : "--rw=read,randr --bs=4k,64k --ioengine=sync --numjobs=1, --filename=/tmp/fio-tst",
#	"ceph-osp" : "--rw=read,randr,write,randw --bs=1m --ioengine=sync --numjobs=1"
#	}
#
#   Since the user provided new values for --bs and --rw, those defaults were replaced with the 
#   user's values.
#
#   Note that the ordering of --defaults and --parameters is important.  These options are processed
#   in order, and doing something like having --defaults=<some-default> after a --parameters
#   can ovverite a parameter.  For example:
#
#   #pbench-gen-iterations fio --rw=read,write --bs=4k,1M --defaults=default
#	pbench_fio --ioengine=sync --filename=/tmp/fio-tst --numjobs=1 --bs=4k --rw=read
#	pbench_fio --ioengine=sync --filename=/tmp/fio-tst --numjobs=1 --bs=4k --rw=randr
#	pbench_fio --ioengine=sync --filename=/tmp/fio-tst --numjobs=1 --bs=64k --rw=read
#	pbench_fio --ioengine=sync --filename=/tmp/fio-tst --numjobs=1 --bs=64k --rw=randr	
#
#   Since --defaults=default was used after --bs and --rw, those parameters were overritten.  This is by design.

use strict;
use warnings;
use File::Basename;
my $pbench_lib_path;
my $script_path;
my $script_name;
BEGIN {
	$script_path = dirname($0);
	$script_name = basename($0);
	$pbench_lib_path = $script_path . "/postprocess";
}

use lib "$pbench_lib_path";
use JSON;
use Data::Dumper;
use PbenchBase qw(get_json_file get_benchmark_names);
my $pbench_bench_config_dir = $script_path;
$pbench_bench_config_dir =~ s/bench-scripts$/config\/benchmark\//;

# load a benchmark json file which tells us how to run a benchmark
sub load_benchmark_specs {
	my $benchmark_name = shift;
	my $benchmark_spec_file = $pbench_bench_config_dir . $benchmark_name . ".json";
	my $json_ref = get_json_file($benchmark_spec_file);
	return %$json_ref
}
# return an array of all the valid arguments for a specific benchmark
sub get_benchmark_args {
	my $spec_ref = shift; # our benchmark spec
	my @args;
	for my $regex_type (keys %{ $$spec_ref{"parameters"}{"specs"} } ) {
		@args = (@args,  @{ $$spec_ref{"parameters"}{"specs"}{$regex_type}{"arguments"} });
	}
	return @args
}
# return a string of the default parameters for a specific benchmark and a specific default_name
sub get_benchmark_defaults {
	my $spec_ref = shift; # our benchmark spec
	my $default_name = shift;
	if ($default_name eq "list") {
		print "defaults available:\n";
		for my $d (grep(!/^mandatory$/, keys $$spec_ref{"parameters"}{"defaults"})) {
			printf("%s: %s\n", $d, $$spec_ref{"parameters"}{"defaults"}{$d});
		}
		exit;
	}
	if ($$spec_ref{"parameters"}{"defaults"}{$default_name}) {
		return $$spec_ref{"parameters"}{"defaults"}{$default_name};
	} else {
		die "That default does not exist";
	}
}
# ensure a parameter's argument can be found and the parameter's values passes the regex requirement
# return nothing if the tests fail
# return the argument and values in an array it they pass
sub process_param {
	my $argument = shift;
	my $values = shift;
	my $spec_ref = shift;
	my $processed_values = "";
	for my $regex_types (keys $$spec_ref{"parameters"}{"specs"}) {
		if (grep(/^$argument$/, @{ $$spec_ref{"parameters"}{"specs"}{$regex_types}{"arguments"} })) {
			for my $value (split(/,/, $values)) { # users can provide multiple values for an option
				if ($value =~ /$$spec_ref{"parameters"}{"specs"}{$regex_types}{"value_regex"}/) {
					if ($$spec_ref{"parameters"}{"specs"}{$regex_types}{"value_transforms"}) {
						for my $transform (@{ $$spec_ref{"parameters"}{"specs"}{$regex_types}{"value_transforms"} }) {
							# in order to apply the 's/x/y/' regex from the file, some eval trickery is necessary
							# todo: first test the $transform regex separately for [perl syntax] errors with eval before doing below
							$value = eval "\$_='$value'; $transform; return scalar \$_";
						}
					}
					if ($processed_values eq "") {
						$processed_values = $value;
					} else {
						$processed_values .= "," . $value;
					}
				} else {
					printf "the value, \'%s\' for value, \'%s\' is not valid\n", $value, $argument;
					return;
				}
			}
			return ($argument, $processed_values);
		}
	}
	return;
}
# generate an array of all benchmark iteration cmds
sub build_iteration_cmds {
	my $cmdline = shift;
	my $multiplex_params_ref = shift; # the parameters which each value creates a new iteration
	my $simplex_params_ref = shift; # the parameters which each value does not create a new iteration
	my %multiplex_params = %$multiplex_params_ref;
	my %simplex_params = %$simplex_params_ref;
	my @cmds;

	if (scalar %multiplex_params) {
		my @args = (keys %multiplex_params);
		my $arg = shift(@args);
		my $values = $multiplex_params{$arg};
		delete $multiplex_params{$arg};
		for my $value (split(/,/, $values)) {
			push(@cmds, build_iteration_cmds($cmdline . " --" . $arg . "=" . $value . " ", \%multiplex_params, \%simplex_params));
		}
		return @cmds;
	} else {
		for my $arg (keys %simplex_params) {
			$cmdline .= " --" . $arg . "=" . $simplex_params{$arg};
		}
		return ($cmdline);
	}	
}

# main program starts here #

# check for required options for pbench-gen-iterations
if (scalar @ARGV == 0) {
	print "You must supply at least a benchmark name:\n";
	get_benchmark_names($pbench_bench_config_dir);
	exit;
}
my $benchmark = shift(@ARGV);
if ($benchmark eq "list") {
	get_benchmark_names($pbench_bench_config_dir);
	exit;
}

# go through the @ARGS and either:
# -swap out "--defaults" with a list of default params
# -validate and transform a "arg=val" parameter
my %pbench_specs = load_benchmark_specs("pbench");
my %bench_specs = load_benchmark_specs($benchmark);
my @params = @ARGV;
my %processed_bench_params; # benchmark-specific parameters that will have been validated and transformed
my %processed_pbench_params; # universal parameters that will have been validated and transformed
# if the user did not specify a set of defaults, use the "default" set and make sure these
# get processed before any other params
if (!grep(/^--defaults=(.+)$/, @params)) { 
	unshift(@params, "--defaults=default");
}
# add the "mandatory" default set and make sure these
# get processed after any other params
push(@params, "--defaults=mandatory");
# now process all of the parameters
while ( scalar @params > 0 ) {
	my $param = shift @params;
	if ($param eq "--help") {
		print "These are the valid universal arguments:\n";
		for my $p (get_benchmark_args(\%pbench_specs)) {
			printf("    --%s\n", $p);
		}
		print "These are the valid $benchmark arguments:\n";
		for my $p (get_benchmark_args(\%bench_specs)) {
			printf("    --%s\n", $p);
		}
	} elsif ($param =~ /^--defaults=(.+)$/) { # expanded to all of the parameters found for that default
		@params = (split(/\s+/, get_benchmark_defaults(\%bench_specs, $1)), @params);
	} elsif ($param =~ /^--(.+)=(.+)$/) { # we now have a parameter, a "--argument=value" that we can process
		my @p;
		if (@p = process_param($1, $2, \%pbench_specs)) {
			$processed_pbench_params{$p[0]} = $p[1];
		} elsif (@p = process_param($1, $2, \%bench_specs)) {
			$processed_bench_params{$p[0]} = $p[1];
		} else {
			printf "the parameter %s did not fit the requirements of pbench or the benchmark\n", $param;
			exit 1;
		}
	} else {
		printf "The format of \'%s\' is not valid\n", $param;
		exit 1;
	}
}
# now we can generate all of the iterations
my @iteration_cmds = build_iteration_cmds("", \%processed_bench_params, \%processed_pbench_params);
for my $cmd (@iteration_cmds) {
	print "$cmd\n";
}
