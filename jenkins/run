#!/bin/bash

# Run commands within the pbench-${IMAGE_ROLE}-${IMAGE_KIND} container image.
#
# Several customizing inputs can be given via environment variables:
#
# EXTRA_PODMAN_SWITCHES []
# IMAGE_REPO [quay.io/pbench]
# IMAGE_ROLE [devel] (see Makefile for options)
# IMAGE_KIND [fedora] (see Makefile for options)
# IMAGE [image spec you want, overrides all of the above]
#
# For example, run an interactive bash shell:
#
#     EXTRA_PODMAN_SWITCHES=-it jenkins/run bash
#
# Or ensure the latest image is used:
#
#     EXTRA_PODMAN_SWITCHES=--pull=always jenkins/run tox
#
# Or perhaps to check out a locally built image:
#
#     EXTRA_PODMAN_SWITCHES=-it IMAGE_ROLE=ci IMAGE_REPO=localhost jenkins/run bash
#
if [[ "$(realpath -e $(pwd)/jenkins)" != "$(realpath -e $(dirname ${0}))" ]]; then
    printf -- "ERROR - Jenkins running from an unexpected directory, %s\n" "$(pwd)" >&2
    exit 1
fi

if [[ -z "${1}" ]]; then
    printf -- "ERROR - missing required arguments for what to run\n" >&2
    exit 1
fi

_branch_name="$(cat jenkins/branch.name)"

_image_repo=${IMAGE_REPO:-quay.io/pbench}
_image_role=${IMAGE_ROLE:-devel}
_image_kind=${IMAGE_KIND:-fedora}

# USER_NAME:  the name of the user (and the home directory) inside the container
# HOME_DIR:   the path to the user's home directory inside the container
# PODMAN_SOCK: the path to the Podman remote socket both in-/outside the container
# WORKSPACE:  the directory containing the Git checkout -- in the Jenkins
#             environment this is set and setup for us; otherwise, it defaults to
#             the current working directory, which is required by this script to
#             be a Git checkout.
#             NOTE:  this is the path on the HOST, if we're already in a container;
#             inside the container, it will be mapped to /home/${USER}/pbench.
USER_NAME=${USER}
HOME_DIR=/home/${USER_NAME}
PODMAN_SOCK=/run/user/${UID}/podman/podman.sock
WORKSPACE=${WORKSPACE:-$(pwd)}

# The PBR in our setup.py Pbench installer relies on `git` knowledge and can't
# handle a git worktree. This handy sequence solves the problem by importing
# the base git tree into the container along with the worktree.
GIT_BASE_VOLUME=""
git_dir="$(git rev-parse --absolute-git-dir)"
if [ "${git_dir}" != "$(pwd)/.git" ]; then
    git_common_dir="$(git rev-parse --git-common-dir)"
    GIT_BASE_VOLUME="--volume ${git_common_dir}:${git_common_dir}:z"
fi

_image=${IMAGE:-${_image_repo}/pbench-${_image_role}-${_image_kind}:${_branch_name}}

if [ -n "${CONTAINER_HOST}" ]; then
    # Since CONTAINER_HOST is defined, when we want to run another container, do
    # it with `podman-remote` (which will run it where CONTAINER_HOST points).
    # This works nicely, e.g., if we are already inside a properly configured
    # container.
    PODMAN="podman-remote"
else
    # Since CONTAINER_HOST is not defined, don't invoke the container remotely.
    # However, we might want to run a container "remotely" on this host;
    # therefore, enable the service which makes it available to receive
    # `podman-remote` invocations.  This creates a listener on
    # /run/user/$(id -u)/podman/podman.sock, which will be mapped into the
    # container in the invocation below so that we can create peer-containers
    # on this host from inside the container.
    PODMAN="podman"
    systemctl --user enable --quiet --now podman.socket
fi

${PODMAN} run \
    --userns=keep-id \
    --security-opt label=disable \
    --volume ${HOME_DIR} \
    --volume ${HOME_DIR}/.config \
    --volume ${WORKSPACE}:${HOME_DIR}/pbench \
    --volume ${PODMAN_SOCK}:${PODMAN_SOCK} \
    ${GIT_BASE_VOLUME} \
    -w ${HOME_DIR}/pbench \
    --env HOME=${HOME_DIR} \
    --env USER=${USER_NAME} \
    --env CONTAINER_HOST=unix:/${PODMAN_SOCK} \
    --env WORKSPACE=${WORKSPACE} \
    --ulimit nofile=65536:65536 \
    --rm \
    ${EXTRA_PODMAN_SWITCHES} \
    ${_image} \
    jenkins/runner "${@}"
